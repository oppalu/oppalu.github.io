{"meta":{"title":"Phoebe's blog","subtitle":"分享一些学习上的心得经验","description":"高露在Github上的个人博客","author":"Phoebe Gao","url":"http://oppalu.github.io"},"pages":[{"title":"分类","date":"2016-12-15T12:28:06.000Z","updated":"2016-12-15T12:28:36.000Z","comments":true,"path":"categories/index.html","permalink":"http://oppalu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-12-15T12:25:57.000Z","updated":"2016-12-15T12:29:33.000Z","comments":true,"path":"tags/index.html","permalink":"http://oppalu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发编程常见问题整理","slug":"Java并发编程常见问题整理","date":"2019-03-04T06:11:45.000Z","updated":"2019-03-04T14:47:22.786Z","comments":true,"path":"2019/03/04/Java并发编程常见问题整理/","link":"","permalink":"http://oppalu.github.io/2019/03/04/Java并发编程常见问题整理/","excerpt":"最近准备面试的时候发现在典型的Java技术类面试中，多线程问题几乎是必考考点会经常被问到。Java内置了对于并发的支持，之前在开发中可能只是简单的用过类似synchronized关键字，但是并不完全了解Java的多线程设计，如其他的并发工具等。复习的时候参考了博客，《Java并发编程实战》以及《操作系统》，整理了一些常见的Java多线程编程的问题与知识点，方便日后自己的复习学习。可能有些地方见解不尽正确，如果有人发现敬请指正:)","text":"最近准备面试的时候发现在典型的Java技术类面试中，多线程问题几乎是必考考点会经常被问到。Java内置了对于并发的支持，之前在开发中可能只是简单的用过类似synchronized关键字，但是并不完全了解Java的多线程设计，如其他的并发工具等。复习的时候参考了博客，《Java并发编程实战》以及《操作系统》，整理了一些常见的Java多线程编程的问题与知识点，方便日后自己的复习学习。可能有些地方见解不尽正确，如果有人发现敬请指正:) 进程与线程的基础知识并发与并行的区别并发：在同一时间间隔内多个任务同时执行。宏观并行，微观串行，单核处理器就可以做到。并行：在同一时刻多个任务同时执行。宏观与微观均并行，多核处理器才可以做到。 进程与线程以及他们的区别进程是具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源调度和分配的独立单位线程是进程中能够并发执行的实体，是进程的组成部分，是处理器调度的基本单位。线程是进程的子集，一个进程可以有很多线程。进程在执行过程中拥有独立的内存空间，而多个线程共享进程的内存。 操作系统的进程调度策略？先来先服务fcfs：每次从就绪队列中选择最先进入的进程优先级调度：从就绪队列中找优先级最高的轮转调度（时间片调度）：每次把cpu分给就绪队列首进程使用规定的时间片，就绪队列的每个进程轮流使用一个时间片，用完后让出cpu并排到就绪队列尾部。多级反馈队列调度算法：建立多个优先级不同的队列，队内fcfs 进程间的通信方式？信号通信机制：通过软中断提供信号的通信机制。管道通信机制：对于管道文件的读写实现。用于具有亲缘关系的进程间的通信，fifo命名管道可在无关进程间交换数据消息队列：使用信箱和发信/收信原语共享内存：使用信号量及其原语操作（PV、读写锁、管程）控制套接字socket 进程的状态运行态running：进程占有处理器正在运行就绪态ready：进程具备运行条件，等待系统分配处理器以便运行（如时间片用完）等待态wait：阻塞/睡眠态，进程不具备运行条件，正在等待某个事件完成（等待时间结束进入就绪态） 线程的状态新建态new：还没开始运行的线程处于这种状态可运行Runnable：可能正在运行，也可能正在等待 CPU 时间片。阻塞Blocked：等待获取一个排它锁[被动]无限期等待Waiting：无限期的等待另一个线程执行特定方法的线程处于这种状态限期等待Timed waiting：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。[主动]终止Terminated：已经退出（运行结束）的线程处于这种状态 进程的同步机制？原子操作，信号量机制，自旋锁，管程 线程的同步方式？互斥量：互斥对象，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。信号量：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。事件/信号(wait&amp;notify)：通过通知操作的方式来保持多线程同步，允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。 守护线程 唯一用途是为其他线程提供服务(如计时线程, GC线程) 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 t.setDaemon(true)转换成守护线程。（要在start()之前调用） 线程的使用如何创建线程？继承Thread类覆写父类中的 run() 方法，新线程类创建线程。当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 实现Runnable接口重写run()方法来定义线程的行为，通过 Thread 调用 start() 方法来启动线程。12345678910public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现Callable接口与 Runnable 相比，Callable 的 call() 方法可以返回值和抛出异常，FutureTask 类构造创建方法体，Thread 类创建线程123456789101112public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 对比 Thread受限于 Java 的单继承，线程间无法共享变量 实现了Runnable接口的类可在线程间共享，适合于多个线程处理同一个任务的情况。 线程中的常用方法start()在使用 new 关键字创建一个线程后，CPU 并不会执行线程中的代码。只有在 start() 方法执行后，才表示这个线程变成Runnable 态，至于何时真正运行还要看线程调度器的调度 run()当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。如果直接调用 run() 方法，就会被当做普通方法来使用。 join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。 sleep()主动放弃占用的处理器资源，该线程进入阻塞状态，指定的睡眠时间超时后，线程进入就绪状态等待线程调度器的调用。 yield()主动放弃占用的处理器资源，线程直接进入就绪状态等待线程调度器的调用。 Executor框架框架图下图是Executor框架常用接口与子类的框架图： Executor：定义了一个接收Runnable对象的方法execute(Runnable command) ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法 AbstractExecutorService：ExecutorService执行方法的默认实现 ScheduledExecutorService：一个可定时调度任务的接口 ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池 ThreadPoolExecutor：线程池，可以通过调用Executors的静态工厂方法来创建线程池并返回一个ExecutorService对象 线程池使用线程池的优点： 避免了不断创建和销毁线程导致的性能开销。 当请求到达时，工作线程通常已经存在，不会由于等待线程创建而延迟任务的执行，从而提高了响应性。 可有效控制最大并发线程数，防止过多线程相互竞争资源而使应用程序耗尽内存或失败。通过Executors可以创建哪些线程池？ newFixedThreadPool：创建一个定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量。 newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newSingleThreadExecutor：是一个单线程的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照队列中指定顺序(FIFO, LIFO, 优先级)执行。如果异常会创建另一个线程来代替。 newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。（多数情况下可用来替代Timer类。） Executor简介 Executor提供了一种标准的方法管理多个异步任务的执行，将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者。 “在线程池中执行任务”： 对于实现Runnable接口的对象，执行器通过execute方法将任务提交到工作队列中，工作线程反复的从工作队列中取出任务并执行12345678//examplepublic static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new MyRunnable()); &#125; executorService.shutdown();&#125; 执行过程 如果线程池的大小小于配置的corePoolSize，说明还可以创建新线程，则启动新的线程执行这个任务。 如果线程池的大小大于配置的corePoolSize，会把任务加入任务队列即可。如果任务队列不满(即放入成功)，则提交的任务在任务队列中等待处理；否则则需要考虑是否要扩展线程池的容量。 当线程池已经关闭或者上面的条件都不能满足时，则进行拒绝策略，拒绝策略在RejectedExecutionHandler接口中定义 中断interrupt() 通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。 调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程 不能中断 I/O 阻塞和 synchronized 锁阻塞。1234567891011121314151617public class InterruptExample &#123; private static class MyThread2 extends Thread &#123; @Override public void run() &#123; while (!interrupted()) &#123; // .. &#125; System.out.println(&quot;Thread end&quot;); &#125; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();&#125; Executor的中断操作 调用 Executor 的 shutdown() 方法会等线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。 线程的互斥同步锁机制synchronized 是JVM实现的内置锁。是一种互斥锁，最多只有一个线程能持有这种锁。 可用于同步一个代码块，一个方法，一个类等 12345678910111213public void func() &#123; synchronized (this) &#123; // ... &#125;&#125;public synchronized void func () &#123; // ...&#125;public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 线程进入同步代码块之前自动获得锁，退出时自动释放[释放前会将修改的变量同步更新到内存中] 可重入，即锁的粒度是线程而非调用[一个线程可以获得自己已经持有的锁，用一个计数值，再次获得时递增退出递减0时释放]显式锁 lock()&amp;unlock() ReentrantLock： java.util.concurrent包中的锁，保证任何时刻只有一个线程进入临界区 ReentrantLock 可中断，而 synchronized 不行 synchronized与ReentrantLock对比 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 wait() notify() notifyAll() wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 它们都属于 Object 的一部分，而不属于 Thread。 await(), signal(), signalAll() java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，在 Condition 上调用 await()方法使线程等待，其它线程调用 signal()或 signalAll()方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 J.U.C工具类闭锁相当于门，闭锁到达结束状态前门一直关闭，并且没有任何线程能通过。到达时允许所有线程通过 CountDownLatch 用来控制一个线程等待多个线程。 维护了一个计数器cnt，每次调用countDown()方法会让计数器的值减1。await()方法会等待计数器达到0(表示所有需要等待的事件都已经发生)，然后唤醒等待的线程。 CyclicBarrier 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。（闭锁用于等待事件，栅栏用于等待其他线程） 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行await()方法之后计数器会减1，并进行等待，直到计数器为0，所有调用await()方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 有acquire()和release()方法 FutureTask 既可以当做一个任务执行，也可以有返回值 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。1234567891011121314151617FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int result = 0; //长时间计算 for (int i = 0; i &lt; 100; i++) &#123; Thread.sleep(10); result += i; &#125; return result; &#125; &#125;); Thread computeThread = new Thread(futureTask); computeThread.start(); //先做完别的逻辑 System.out.println(futureTask.get()); BlockingQueue 提供了阻塞的 take() 和 put() 方法：如果队列为空 take()将阻塞，直到队列中有内容；如果队列为满 put()将阻塞，直到队列有空闲位置。 FIFO 队列：LinkedBlockingQueue、ArrayBlockingQueue（固定长度） 优先级队列：PriorityBlockingQueue 线程安全不可变Immutable 一定是线程安全的 final, String, enum, Number部分子类(Long, Double, BigInteger) 无共享数据 栈封闭：访问局部变量，因为局部变量在栈中是线程私有的 ThreadLocal：为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量 存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递 线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收 在Thread类中有一个Map，用于存储每一个线程的变量的副本。 volatile变量 确保将变量的更新操作通知到其他线程 一旦某个线程修改了该被volatile修饰的变量，它会保证修改的值会立即被更新到主存。当有其他线程需要读取时，volatile变量总会返回最新写入的值 使用条件：对变量的写入操作不依赖变量的当前值；该变量不会与其他状态变量一起纳入不变性条件；访问变量时不需要加锁 Java内存模型先行发生原则 单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作 管程锁定原则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 锁优化自旋锁在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 多线程开发的良好实践 给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。如对于 synchronized，应尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.mdhttp://www.importnew.com/12773.html","categories":[{"name":"Java","slug":"Java","permalink":"http://oppalu.github.io/categories/Java/"}],"tags":[{"name":"Java 并发 多线程","slug":"Java-并发-多线程","permalink":"http://oppalu.github.io/tags/Java-并发-多线程/"}]},{"title":"高级算法设计与分析技术——动态规划","slug":"高级算法设计与分析技术","date":"2019-02-14T02:24:28.000Z","updated":"2019-03-01T12:10:46.656Z","comments":true,"path":"2019/02/14/高级算法设计与分析技术/","link":"","permalink":"http://oppalu.github.io/2019/02/14/高级算法设计与分析技术/","excerpt":"做算法题的时候遇到过很多动态规划相关的问题，但是了解了大致的解法却没有仔细的学习过动态规划的知识。想着单纯的做算法题不如了解解体的通法重要，就结合着《算法导论》一书和一些相关的博客内容整理了包括动态规划在内的一些高级算法设计与分析技术。只是自己学习的笔记，可能有些地方见解不尽正确，如果有人发现敬请指正:)","text":"做算法题的时候遇到过很多动态规划相关的问题，但是了解了大致的解法却没有仔细的学习过动态规划的知识。想着单纯的做算法题不如了解解体的通法重要，就结合着《算法导论》一书和一些相关的博客内容整理了包括动态规划在内的一些高级算法设计与分析技术。只是自己学习的笔记，可能有些地方见解不尽正确，如果有人发现敬请指正:) 动态规划原理概述动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。动态规划的核心在于记住已经解决过的子问题的解，利用查表代替调用函数递归。分治的话会反复的求解公共的子子问题，而动态规划对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算动态规划一般会用来解决最优化问题，即求问题的最优解 应用动态规划方法求解最优化问题应具备两个要素：最优子结构和子问题重叠。 最优子结构用动态规划法求解最优化问题的第一步就是刻画最优解的结构。如果一个问题的最优解包含其子问题的最优解，则该问题具有最优子结构性质。 子问题重叠子问题空间必须足够小，即问题的递归算法会反复的求解相同的子问题而不是一直产生新的子问题。动态规划对每个子问题求解一次，就将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。 动态规划算法的两种形式由上面可知动态规划算法的核心是记住已经求过的解，记住的方法有自底向上和带备忘的自顶向下算法两种。我用最简单的斐波那契问题为例 带备忘的自顶向下算法它的思路在于创建一个数组来保存每次计算的子问题的解。 对于斐波那契问题而言，就是创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在数组中，下次在调用fib（n）的时候就不会重新递归了。 自底向上通常自底向上使用最优子结构。即首先求子问题的最优解，然后根据子问题得到原问题的最优解。对于斐波那契问题而言，就是先计算出fib（1），fib（2），fib（3）等并保存下来，再计算原问题的解。 例子：钢条切割问题上图是算法导论里的一道例题。用这个问题来对上面的解法做一些更直观的理解。 一般的递归算法递归算法思路比较容易理解，就不进行介绍。由于有大量重复计算递归效率较低。12345678910public static int cut(int []p,int n)&#123; if(n==0) return 0; int q=Integer.MIN_VALUE; for(int i=1;i&lt;=n;i++) &#123; q=Math.max(q, p[i-1]+cut(p, n-i)); &#125; return q;&#125; 带备忘的自顶向下算法备忘算法也很容易理解，就是在递归的时候保存每次已经运行过的子问题的结果。1234567891011121314151617181920public static int cutMemo(int []p)&#123; int []r=new int[p.length+1]; for(int i=0;i&lt;=p.length;i++) r[i]=-1; return cut(p, p.length, r);&#125;public static int cut(int []p,int n,int []r)&#123; int q=-1; if(r[n]&gt;=0) return r[n]; if(n==0) q=0; else &#123; for(int i=1;i&lt;=n;i++) q=Math.max(q, cut(p, n-i,r)+p[i-1]); &#125; r[n]=q;//保存每次的结果 return q;&#125; 自底向上自底向上的思路比较难理解，关键在于中间的二层for循环。外面的循环是求r1,r2……，里面的循环是求出r1,r2……的最优解，也就是说r[i]中保存的是钢条长度为i时划分的最优解，这里面涉及到了最优子结构问题，也就是一个问题取最优解的时候，它的子问题也一定要取得最优解。12345678910public static int buttom_up_cut(int []p)&#123; int []r=new int[p.length+1]; for(int i=1;i&lt;=p.length;i++)&#123; int q=-1; for(int j=1;j&lt;=i;j++) q=Math.max(q, p[j-1]+r[i-j]); r[i]=q; &#125; return r[p.length];&#125; PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://blog.csdn.net/u013309870/article/details/75193592","categories":[{"name":"算法","slug":"算法","permalink":"http://oppalu.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://oppalu.github.io/tags/动态规划/"}]},{"title":"JVM学习笔记(4)——JAVA类加载机制","slug":"JVM学习笔记-4-——JAVA类加载机制","date":"2019-02-12T12:13:55.000Z","updated":"2019-02-13T07:38:01.330Z","comments":true,"path":"2019/02/12/JVM学习笔记-4-——JAVA类加载机制/","link":"","permalink":"http://oppalu.github.io/2019/02/12/JVM学习笔记-4-——JAVA类加载机制/","excerpt":"上一篇介绍了Java class文件的存储格式。在class文件中描述的各种信息最终都需要加载到虚拟机中才能被运行和使用。而虚拟机如何加载这些class文件，class文件进入虚拟机后又会发生什么变化？本篇笔记就会结合《深入理解Java虚拟机》一书的第7章内容作简要的介绍。","text":"上一篇介绍了Java class文件的存储格式。在class文件中描述的各种信息最终都需要加载到虚拟机中才能被运行和使用。而虚拟机如何加载这些class文件，class文件进入虚拟机后又会发生什么变化？本篇笔记就会结合《深入理解Java虚拟机》一书的第7章内容作简要的介绍。 类的生命周期Java中，类是在运行期间第一次使用时动态加载的，而不是一次性加载。类的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备和解析3个部分统称为连接(Linking)。加载、验证、准备、初始化和卸载的顺序是确定的，而解析阶段某些情况下可在初始化阶段后再开始(运行时的动态绑定)。 类初始化的时机主动引用虚拟机规范中严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）。这5种场景中的行为称为对一个类进行主动引用： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用JDK 1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且该方法句柄所对应的类没有初始化过，则先触发初始化。 被动引用所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义, SubClass不会初始化 通过数组定义来引用类，不会触发此类的初始化。（该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。） 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 1System.out.println(ConstClass.HELLOWORLD) 类加载的过程加载：查找并加载类的二进制数据加载阶段，虚拟机需要完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 验证：确保被加载的类的正确性验证是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成下面4个阶段的检验动作： 文件格式验证：即验证字节流是否符合Class文件格式规范 元数据验证：对字节码描述信息进行语义分析，以保证其描述的信息符合Java语言规范的要求(如是否有父类，是否继承了不允许继承的类，是否实现了父类或接口中要求实现的所有方法等) 字节码验证：最复杂，通过数据流和控制流分析，确定程序语义的合法性和逻辑性。（如跳转指令不会跳到方法体之外，方法体中类型转换有效等） 符号引用验证：发生在解析阶段，可看做是对类自身以外的信息进行匹配性校验，目的保证解析动作能正常执行，如果无法通过符号引用验证，则会抛出异常。(如访问性级别等) 准备：为类的静态变量分配内存并初始化准备阶段是正式为类变量分配并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中。这里所说的初始值“通常情况”是数据类型的零值12345//value在准备阶段过后的初始值为0而不是1,而把value赋值的putstatic指令将在初始化阶段才会被执行。public static int value = 1;//此时准备阶段value赋值为1public static final int value = 1; 解析：把类中的符号引用转换为直接引用解析阶段是将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用不尽相同。 初始化初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 &lt; clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 &lt; clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 由于父类的 &lt; clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 2&#125; &lt; clinit&gt;() 方法不是必须的，如果没有静态语句块和赋值操作就可以没有。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt; clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt; clinit&gt;() 方法不需要先执行父接口的 &lt; clinit&gt;() 方法。 虚拟机会保证一个类的 &lt; clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。 类加载器比较两个类相等，只有在这两个类使用同一个类加载器进行加载的前提下才有意义。这是因为每一个类加载器都拥有一个独立的类名称空间。 类的加载类加载有三种方式： 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 类加载器种类从JVM角度，只存在两种不同的类加载器：启动类加载器和其他的。细分可如下： 启动类加载器(Bootstrap ClassLoader)使用 C++ 实现，是虚拟机自身的一部分负责将存放在 &lt; JRE_HOME &gt;\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt; JAVA_HOME &gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都要有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 工作过程如果一个类加载器收到了类加载的请求，它会首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试自己加载。 优点使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。无论那个类加载器要加载这个类，最终都是委托给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。（防止内存中出现多份同样的字节码） 实现1234567891011121314151617181920212223242526protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先检查请求的类是否已经被加载过了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; //如果父类加载器抛出异常说明父类加载器无法完成加载请求 &#125; if (c == null) &#123; // 父类无法加载调用自身的findClass方法进行类加载 c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6http://www.cnblogs.com/ityouknow/p/5603287.htmlhttps://blog.csdn.net/w760079528/article/details/77845267","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JVM学习笔记(3)——JAVA类文件结构","slug":"JVM学习笔记-3-——JAVA类文件结构","date":"2019-02-09T10:32:07.000Z","updated":"2019-02-09T16:26:14.041Z","comments":true,"path":"2019/02/09/JVM学习笔记-3-——JAVA类文件结构/","link":"","permalink":"http://oppalu.github.io/2019/02/09/JVM学习笔记-3-——JAVA类文件结构/","excerpt":"前面大概介绍了JVM的运行时数据区域以及JVM的垃圾回收和内存分配策略，这一篇主要是针对书中第6章内容整理JAVA的类文件结构。Java语言的特点在于跨平台，通过将源文件编译成与操作系统无关的，只有虚拟机能识别并执行的字节码文件，由各个操作系统上的jvm来负责执行，屏蔽了底层具体的操作系统。这一篇主要就是介绍一下这个字节码文件的性质，为之后介绍Java的类加载机制做好预备知识。","text":"前面大概介绍了JVM的运行时数据区域以及JVM的垃圾回收和内存分配策略，这一篇主要是针对书中第6章内容整理JAVA的类文件结构。Java语言的特点在于跨平台，通过将源文件编译成与操作系统无关的，只有虚拟机能识别并执行的字节码文件，由各个操作系统上的jvm来负责执行，屏蔽了底层具体的操作系统。这一篇主要就是介绍一下这个字节码文件的性质，为之后介绍Java的类加载机制做好预备知识。 Class类文件结构class文件是一组以8位字节为基础的二进制流，其与Java虚拟机指令集和符号表以及若干其他辅助信息相对应。各个数据项严格按照顺序紧凑的排列在class文件中，中间没有添加任何分隔符，使得整个class文件中存储的文件几乎都是程序运行的必要数据。 整体结构class文件采用了类似C语言结构体的形式来存储数据，由无符号数和表两种数据结构组成 无符号数：是class文件基本的数据类型，用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数。 表：是由无符号数或者其他表作为数据项构成的复合数据类型，以_info 结尾。用于描述有层次关系复合结构的数据整体上看，类文件整体结构如下图所示，具体每项在后文介绍。 文件数据项用一个简单的例子来介绍class文件。Test.java123456789package org.tianbin.clazz;public class Test&#123; private int m; public int inc()&#123; return m + 1; &#125;&#125; Test.class12345678910111213CA FE BA BE 00 00 00 34 00 13 0A 00 04 00 0F 09 00 03 00 10 07 00 11 07 00 12 01 00 01 6D 01 00 01 49 01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01 00 03 69 6E 63 01 00 03 28 29 49 01 00 0A 53 6F 75 72 63 65 46 69 6C 65 01 00 09 54 65 73 74 2E 6A 61 76 61 0C 00 07 00 08 0C 00 05 00 06 01 00 16 6F 72 67 2F 74 69 61 6E 62 69 6E 2F 63 6C 61 7A 7A 2F 54 65 73 74 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 00 21 00 03 00 04 00 00 00 01 00 02 00 05 00 06 00 00 00 02 00 01 00 07 00 08 00 01 00 09 00 00 00 1D 00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 01 00 0A 00 00 00 06 00 01 00 00 00 03 00 01 00 0B 00 0C 00 01 00 09 00 00 00 1F 00 02 00 01 00 00 00 07 2A B4 00 02 04 60 AC 00 00 00 01 00 0A 00 00 00 06 00 01 00 00 00 07 00 01 00 0D 00 00 00 02 00 0E 魔数1CA FE BA BE //class文件的头4个字节（咖啡baby2333） 魔数是用来确定文件是否是一个能够被虚拟机接受的class文件。由于文件扩展名可以随意改动，因此只靠文件扩展名来确定文件类型并不可靠。 主次版本号100 00 00 34 魔数后4个字节，第5个和第6个字节是次版本号，第7个和第8个字节是主版本号（从45开始）。虚拟机可以向下兼容运行class文件，但不能运行高于其版本的class文件。 常量池结构：容量计数器（u2类型）+ 常量容量计数器从1开始，目的是满足某些常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池”的含义。例子中00 13，表示有12项常量(索引范围为1-12) 常量池中存放两大类常量： 字面量（Literal）: 类似Java中的常量，如文本字符串，声明为final的常量值等。 符号引用（Symbolic References）：包括类和接口的全限定名（Full Qualified Name）,字段的名称和描述符（Descriptor），方法的名称和描述符这三类常量。 常量池中每一项常量都是一个表，共有14种常量表类型，所有常量表开始第一位为u1类型的标志位，标识常量类型。读取常量池的时候首先读取标志位，判断常量类型，就可以知道对应的结构，获取对应的信息了。下图展示了14种常量的具体类型和对应的标志位：每种类型的结构如下（其中u1表示1个字节，u2表示2个字节，其他类似）：示例中的常量池示例可参见附录中的参考博客1 访问标志常量池之后两个字节标识类的访问标志，用于识别一些类或者接口层次的访问信息，即这个class是类还是接口，是否为public等信息。具体标志位及标志含义见下图 类索引、父类索引、接口索引12300 03 类索引 //org/tianbin/clazz/Test00 04 父类索引 //java/lang/Object 00 00 接口索引集合大小 类索引、父类索引都是一个u2类型的数据。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。它们会对应到常量池中的CONSTANT_Class_info类描述符常量，通过常量中的索引值就可以找到定义在CONSTANT_Utf8_info类的全限定名字符串。接口索引集合是一组u2类型的数据的集合。第一项u2类型的数据为接口计数器，表示接口索引表的容量，之后的每两个字节表示一个接口索引，用法同类索引与父类索引。 字段表集合1234500 01 fields_count00 02 access_flags00 05 name_index //m00 06 descriptor_index00 00 attributes_count 字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段表使用标志位表示修饰符，引用常量池中的常量描述字段名及字段数据类型。access_flags可以设置的标志位和含义见下图name_index代表字段的简单名称。descriptor_index代表字段和方法的描述符。对于字段来说用来描述字段的数据类型；而对于方法来说，描述的就是方法的参数列表（包括数量、类型以及顺序）和返回值。具体如下图所示： 方法表集合100 02 method_count //&lt;init&gt; inc class文件中对方法的描述与以前对字段的描述几乎完全一致的方式，唯一的区别就是访问类型不完全一致。方法标志具体见下： 属性表集合Class文件、字段表、方法表都可以有自己的属性表集合，用于描述某些场景的专有信息。符合规范的属性表基本结构如下：其中前两个字节为指向常量池中的CONSTANT_Utf8_info类型的属性名称，之后4个字节表示属性值所占用的位数，最后就是具体属性了。 在具体属性中，列举几个比较重要的，剩下的可自行查阅《深入理解JVM》一书： Code属性用来存储Java程序方法体中的代码经过编译处理后生成的字节码指令。每个指令是一个u1类型的单字节，共可以表达256条指令。 Exception属性用于列举方法中可能抛出的受查异常 SourceFile属性该属性是一个定长属性，用于记录生成这个Class文件的源码文件名称 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://tb-yangshu.github.io/2017/05/11/java_bytecode_structure/#morehttps://www.cnblogs.com/zawier/p/6659311.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JVM学习笔记(2)——垃圾回收机制与内存分配策略","slug":"JVM学习笔记-2-——垃圾回收机制与内存分配策略","date":"2019-02-06T07:29:35.000Z","updated":"2019-03-08T05:33:51.570Z","comments":true,"path":"2019/02/06/JVM学习笔记-2-——垃圾回收机制与内存分配策略/","link":"","permalink":"http://oppalu.github.io/2019/02/06/JVM学习笔记-2-——垃圾回收机制与内存分配策略/","excerpt":"上一篇博客主要介绍了Java的内存区域模型。这篇主要根据书中第3章内容和一些博客介绍一下Java的垃圾回收机制和内存分配策略。由于在Java的运行数据区中，程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，随线程而生，随线程而灭，在方法结束或线程结束时，内存自然就跟着回收了，不需要过多考虑回收的问题。而Java堆和方法区是共享的，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这两者。","text":"上一篇博客主要介绍了Java的内存区域模型。这篇主要根据书中第3章内容和一些博客介绍一下Java的垃圾回收机制和内存分配策略。由于在Java的运行数据区中，程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，随线程而生，随线程而灭，在方法结束或线程结束时，内存自然就跟着回收了，不需要过多考虑回收的问题。而Java堆和方法区是共享的，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这两者。 垃圾收集判断哪些对象应被回收引用计数算法主要思路：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。问题：难以解决对象之间相互循环引用的问题。在两个对象出现循环引用的情况下，引用计数器永远不为 0，导致无法对它们进行回收。1234567891011public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; &#125;&#125; 正因为循环引用的存在，因此Java虚拟机不使用引用计数算法。 可达性分析算法主要思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。Java中可作为GC Roots的对象包括以下几种： 虚拟机栈中局部变量表中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中Native方法引用的对象 finalize()宣告对象死亡的两次标记过程： 没有与GC Roots相连接的引用链则被第一次标记并进行一次筛选，筛选条件为是否有必要执行该对象的finalize方法。若对象没有覆盖finalize方法或者该finalize方法是否已经被虚拟机执行过了，则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有被执行过，那么，这个对象会被放置在一个叫F-Queue的队列中。 对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GC Roots引用链，如把this关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，如果对象还是没有拯救自己，那就会被回收。由于对象的finalize方法最多被虚拟机调用一次，因此它只能拯救自己一次。 回收方法区方法区的垃圾回收主要回收两部分内容：1. 废弃常量。2. 无用的类。 废弃常量：类似于回收Java堆中的对象 无用的类：满足以下三个条件的无用类可以被回收(不是一定，可以通过配置参数来控制是否对类进行回收) 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例 加载该类的 Class Loader 已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 引用类型1.强引用：只要强引用还存在，垃圾收集器就不会回收掉被引用的对象，通常使用new一个新对象的方式来创建强引用。1Object obj = new Object(); 2.软引用：描述还有用但非必需对象。在内存不够的情况下会被回收。Java中的类SoftReference表示软引用。123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.弱引用：描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。4.虚引用：一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。Java中的类PhantomReference表示虚引用。 JVM内存模型(新生代，老生代关系)因为后文垃圾回收部分有大量涉及新生代、老生代等的知识，这里先简单的介绍一下两者。如上图所示，堆被划分成两个不同的区域：新生代 ( Young ) 和老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。 老年代老年代存放的都是存活时间较久的，大小较大的对象(通常约为堆容量的2/3)。使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC）。 EdenEden位于Java堆的年轻代，是新对象分配内存的地方。默认情况下Edem : from : to = 8 :1 : 1 SurvivorSurvival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。 垃圾收集算法(内存回收的方法论)标记-清除算法首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象(标记可参考前文finalize部分)缺点： 标记和清除过程效率都不高 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 复制算法将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。缺点：内存缩小为了原来的一半代价较高现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 标记-整理算法复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。： 分代收集算法根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。 新生代(大批对象死去、少量对象存活的)：复制算法 老年代(对象存活率高、没有额外空间进行分配担保的)：“标记-清除”或“标记-整理”算法 垃圾收集器(内存回收的具体实现)上图展示了7种垃圾收集器，连线表示垃圾收集器可以配合使用。 Serial收集器Serial收集器是一个单线程的收集器，只会使用一个线程进行垃圾收集工作。它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。（Stop the world，难以接受）优点在于简单高效，是虚拟机运行在Client模式下的默认新生代收集器。 ParNew收集器是Serial的多线程版本。是 Server 模式下首选的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 Parallel Scavenge收集器是使用复制算法的并行的多线程收集器。是虚拟机运行在Server模式下的默认垃圾收集器。其他收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。因此也被称为“吞吐量优先收集器”停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。 Serial Old收集器Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 Parallel Old收集器是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 CMS收集器CMS（Concurrent Mark Sweep）是一种使用标记-清除算法，以获取最短回收停顿时间为目标的收集器。适合用于互联网等重视服务的响应速度，希望系统停顿时间最短的情况。整个过程分为4个步骤： 初始标记：仅仅是标记一下 GC Roots 能直接关联到的对象，速度很快，需要STW 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要STW 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要STW 并发清除：回收内存空间，时间很长,不需要STW 缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。 G1收集器(jdk1.6没有)是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。可直接对新生代和老年代一起回收。 特点： 并行和并发：使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。 分代收集 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 主要步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 内存分配与回收策略内存分配规则：对象优先在Eden分配对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC备注： Minor GC: 回收新生代上，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。【当Eden 空间满时触发】 Major GC/Full GC: 指发生在老年代的GC，出现Major GC，经常会伴随至少一次Minor GC。老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。【触发条件见后】 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 长期存活的对象将进入老年代虚拟机为每个对象定义了一个对象年龄计数器。对象出生在Eden区、经过一次Minor GC后仍然存活，并能够被Survivor容纳，设置年龄为1，对象在Survivor区每次经过一次Minor GC，年龄就加1，当年龄达到一定程度（默认15），就晋升到老年代，-XX:MaxTenuringThreshold 用来定义年龄的阈值。 动态对象年龄判定虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。否则进行Full GC。 Full GC 的触发条件 调用 System.gc()【不建议使用，让虚拟机管理内存】 老年代空间不足 空间分配担保失败 Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足便会报 Concurrent Mode Failure 错误，并触发 Full GC。 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.mdhttps://blog.csdn.net/zp522123428/article/details/53635161https://www.cnblogs.com/xiaoxi/p/6486852.htmlhttps://www.cnblogs.com/xiaoxi/p/6557473.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JVM学习笔记(1)——内存区域","slug":"JVM学习笔记-1-——内存区域","date":"2019-02-05T12:33:52.000Z","updated":"2019-02-13T08:07:27.533Z","comments":true,"path":"2019/02/05/JVM学习笔记-1-——内存区域/","link":"","permalink":"http://oppalu.github.io/2019/02/05/JVM学习笔记-1-——内存区域/","excerpt":"之前断断续续的看JVM，这次打算从头完整的学习一遍《深入理解JAVA虚拟机》一书，并利用博客把学习过程记录下来。这篇主要根据书中第2章内容和一些博客介绍一下JAVA的内存区域划分的相关知识。","text":"之前断断续续的看JVM，这次打算从头完整的学习一遍《深入理解JAVA虚拟机》一书，并利用博客把学习过程记录下来。这篇主要根据书中第2章内容和一些博客介绍一下JAVA的内存区域划分的相关知识。 JVM简介JVM即Java Virtual Machine，JAVA程序实际上就是交由JVM执行，我们先来看看JVM的大致组成从上图可以看出，JVM由四大块组成：Class Loader类加载器，JVM运行时数据区，执行引擎和本地接口。这里简单的介绍一下各个部分，虚拟机执行子系统的具体内容会在后续JVM相关的博客中进行介绍。 Class Loader类加载器，主要负责查找，加载，解析 字节码文件(.class后缀)到JVM内存区，以供JVM执行引擎执行加载的字节码。 JVM运行时数据区，具体将在后文进行介绍 执行引擎主要是把可解释的代码，解释为操作系统机器码。当字节码文件被加载到内存后变成了JVM可解释的代码，JVM执行引擎就负责执行这些代码来完成相应的任务。 本地接口主要是把不同语言实现的方法提供给Java调用。 Java程序的具体执行过程如下： 首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)。每个java程序都需要运行在自己的JVM上，并告知 JVM 程序的运行入口 然后JVM中的Class Loader(类加载器)会加载各个类的字节码文件，加载完毕之后，交由JVM中的执行引擎执行。 在整个程序执行过程中，JVM会用一段空间来存储程序执行过程中需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。 运行时数据区域如上图所示，Java虚拟机所管理的内存包括程序计数器，Java虚拟机栈，本地方法栈，方法区，Java堆和运行时常量池几个运行时数据区域，其中方法区和堆由所有线程共享，剩下三个是线程隔离的数据区（如下图示例）。即JVM在初始运行的时候会分配好方法区和堆，之后JVM 每遇到一个线程，就为其分配一个程序计数器，Java虚拟机栈和本地方法栈。 程序计数器程序计数器是一块较小的内存区域，作用是记录当前正在执行的虚拟机字节码指令的地址(如果执行的是Native方法则值为空)。虚拟机在执行字节码时，通过改变PC的值来选择下一条需要执行的字节码指令。每个线程需要有自己独立的程序计数器是为了确保多线程情况下线程切换后可以恢复到正确的执行位置（各线程之间计数器互不影响独立存储）。 Java虚拟机栈Java虚拟机栈描述了Java方法执行的内存模型。每个 Java 方法在执行的同时会创建一个栈帧(Stack frame)用于存储局部变量表(包含了对应的方法参数和局部变量)、操作数栈(实际上就是通过不断地进栈出栈进行计算)、动态连接、方法返回地址等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 这个区域有两种异常情况： 如果线程请求的栈深度大于虚拟机容许的最大深度，将抛出StackOverflowError异常 如果虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。 本地方法栈本地方法栈与 Java 虚拟机栈类似，区别在于虚拟机栈为执行Java方法服务，本地方法栈为执行Native方法服务(参见上文JVM结构图) Java堆Java堆是虚拟机管理的内存中最大的一块，由所有线程共享。Java堆主要用于存放对象实例以及数组，所有对象都在这里分配内存。对象实例在堆中分配好以后，要在Java虚拟机栈中保存一个4字节的堆内存地址，用来定位该对象实例在堆中的位置，便于找到该对象实例。Java堆是垃圾回收的主要区域，也被成为“GC”堆。（关于垃圾回收会在之后的博客中进行介绍）。堆不需要物理上的连续内存，只要逻辑上连续即可，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 方法区方法区也是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息（包括类的名称、方法信息、字段信息）、常量、静态变量、即时编译器编译后的代码等数据。这个区域也会存在垃圾回收，不过回收的目标主要是针对常量池的回收和对类型的卸载，但是一般比较难实现。在JVM规范中，没有强制要求方法区必须实现垃圾回收。HotSpot 虚拟机把它当成永久代来进行垃圾回收。当无法申请到足够的内存时会抛出OutOfMemoryError异常。 运行时常量池是方法区的一部分。在Class文件中除了类的字段、方法、接口等描述信息外，还有一项是常量池用来存储编译期间生成的字面量和符号引用，这部分会在类加载后被放入这个区域。运行时产生的新常量也可以被放入常量池中，比如 String 类中的 intern() 方法产生的常量。 直接内存直接内存不受JVM管理，它使用native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。动态扩展时也可能出现OutOfMemoryError异常。 对象的访问定位对于堆中对象的访问主要有使用句柄和直接指针两种访问方式： 句柄访问会划分一块内存作为句柄池，栈的reference存储句柄地址，句柄包含对象实例数据和类型数据的地址。好处在于对象被移动时栈的reference本身不需要修改。 直接指针访问中，栈的reference存储对象的地址，对象中包含类型数据的地址。好处是速度更快。 JVM调用实例参见博客https://www.cnblogs.com/hellocsl/p/3969768.html?utm_source=tuicool&amp;utm_medium=referral中给的调用示例 OutOfMemoryError异常 Java堆溢出：不断创建对象造成(提示Java heap space) 虚拟机栈和本地方法栈溢出：栈深度过深，扩展栈内存不够 方法区和运行时常量池溢出：运行大量的类(提示permGen space) 直接内存溢出 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://www.cnblogs.com/hellocsl/p/3969768.html?utm_source=tuicool&amp;utm_medium=referralhttps://www.cnblogs.com/dolphin0520/p/3613043.htmlhttps://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JAVA集合相关整理","slug":"JAVA集合相关整理","date":"2019-02-03T15:34:07.000Z","updated":"2019-03-12T08:31:55.448Z","comments":true,"path":"2019/02/03/JAVA集合相关整理/","link":"","permalink":"http://oppalu.github.io/2019/02/03/JAVA集合相关整理/","excerpt":"概述下面两张图所示是JAVA的集合框架图，从整体上可以发现JAVA容器主要包括了Collection和Map两种。List， Queue和Set集合共同继承Collection这个父接口，Map集合是单独的一个接口。","text":"概述下面两张图所示是JAVA的集合框架图，从整体上可以发现JAVA容器主要包括了Collection和Map两种。List， Queue和Set集合共同继承Collection这个父接口，Map集合是单独的一个接口。 Collection ListList的每一个位置按照索引位置摆放，像一个柜子一层一层的，可以有重复的元素(根据索引找元素) ArrayList：基于动态数组实现,支持随机访问。 Vector：和ArrayList类似，但它是线程安全的。(开销也比 ArrayList 要大，访问速度更慢，因此要避免使用) LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表任何位置插入和删除元素。此外，LinkedList 还可以用作栈、队列和双向队列。 SetSet的每个元素不按顺序进行排序，无序不重复 HashSet：基于哈希表实现，是无序的，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 TreeSet：基于红黑树实现，是有序的，但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 Queue PriorityQueue：基于堆结构实现，可用它来实现优先队列。 MapMap中的每一个元素都是按照键值对的方式存储，一个键对应一个值，键不可以重复，值可以重复，我们可以根据键找到值，也是无序的集合。 HashMap基于哈希表实现，对键进行散列，较快 TreeMap基于红黑树实现，用键的整体顺序对元素进行排序，将其组织成搜索树 HashTable与HashMap类似，区别在于HashMap线程不安全，键最多一个为null值可以为多个null。而HashTable线程安全，键与值都不能为null。（它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全） LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 源码简单分析ArrayList（基于数组实现） 默认大小为10，当容量不够需要扩容时为原来的1.5倍。扩容操作需要调用 Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 由于基于数组实现，删除元素时复杂度为O(N) Fail-fast：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。ArrayList使用一个变量modCount来记录结构发生变化的次数(即添加/删除元素时)，在进行序列化或者迭代等操作时，需要比较操作前后modCount是否改变，如果改变了需要抛出ConcurrentModificationException异常。 Vector 实现与ArrayList类似，但是使用了synchronized进行同步。 每次扩容请求其大小的 2 倍空间 由于效率较低，如果需要同步可以使用Collections.synchronizedList()得到一个线程安全的 ArrayList,或者concurrent并发包下的 CopyOnWriteArrayList 类。12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); CopyOnWriteArrayList concurrent并发包下的类 实现了读写分离，读操作在原始数组上进行，写操作在一个复制的数组上进行，写操作需要加锁(ReetrantLock)，写操作结束后需要把原始数组指向新的复制数组。 适用于读多写少的应用场景。 缺陷在于：写操作需要复制数组使得内存占用。此外读操作不能读到实时性的数据(写操作的数据还未同步到读数组中) LinkedList(基于双向链表实现) 内部节点Node定义了前指针prev和后指针next12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; HashMap(链表+数组) Java定义了一个叫Entry的结构用来存储键值对。它是一个链表，包含了key, value, hashCode, next指针四个字段 Java定义了一个Entry类型的数组table。他的每个位置是一个桶，一个桶存放了一个Entry链表，同一个链表中存放哈希值相同的 Entry。 当插入一个键值对时，先计算K的hashcode，使用除留余数法得到所在的桶下标(如hashCode为115，HashMap大小为16，则得到桶的下标为115%16=3)。 当查找时，先根据hashCode计算键值对所在的桶，然后在对应的链表上顺序查找，时间复杂度和链表的长度成正比。 HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，因此使用第 0 个桶存放键为 null 的键值对。 hash的实现：是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16) 扩容resize() 设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N 参数： capacity: table的默认大小(16)，必须为2^n size: 键值对数量 threshold: size的临界值，size &gt;= threshold的时候就要进行扩容 loadFactor: 装载因子，即table能够使用的比例(默认0.75)，threshold = capacity*loadFactor 需要扩容时，capacity为原来的两倍 要重新计算桶下标：(假设原来是16，现在是32，若原key在第5位是0则不变，否则是原来的key+16) HashMap在并发环境下使用中最为典型的一个问题，就是在HashMap进行扩容重哈希时导致Entry链形成环。一旦Entry链中有环，势必会导致在同一个桶中进行插入、查询、删除等操作时陷入死循环。 HashTable 与HashMap类似，使用 synchronized 来进行同步。不能插入键为null的Entry。 HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode 不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。(HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞) ConcurrentHashMap 如图所示，ConcurrentHashMap本质上是一个Segment数组，而一个Segment实例又包含若干个桶，每个桶中都包含一条由若干个 HashEntry 对象链接起来的链表。多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高。 而HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞 此外通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作； LinkedHashMap 继承自HashMap 内部维护了一个双向链表，用来维护插入顺序 适合在需要输出的顺序和输入的顺序相同的情况下。 其他 TreeSet：实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）。适合于需要按照自然顺序或自定义顺序遍历键的情况下。HashSet是通过HashMap来实现的而TreeSet是通过TreeMap来实现的，因此这里不过多介绍 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA集合","slug":"JAVA集合","permalink":"http://oppalu.github.io/tags/JAVA集合/"}]},{"title":"机器学习related(3) ———— 神经网络","slug":"机器学习related(3) ———— 神经网络","date":"2017-10-15T15:46:26.000Z","updated":"2017-10-16T02:21:12.000Z","comments":true,"path":"2017/10/15/机器学习related(3) ———— 神经网络/","link":"","permalink":"http://oppalu.github.io/2017/10/15/机器学习related(3) ———— 神经网络/","excerpt":"","text":"Model Representation神经网络模型是许多逻辑单元(Logistics Unit)按照不同的层级组织起来的网络，每一层的输出变量作为下一层的输入变量。如下图，是一个三层的神经网络，第一层为输入层(Input Layer)，最后一层为输出层(Output Layer)，中间的一层为隐藏层(Hidden Layer)。我们为每一层都增加一个偏倚单位(Bias Unit【值永远为1】)*注：①上述权重矩阵的大小为行是j+1层的激活单元数，列是j层的+1（有一个偏移单元）②h和g函数采用sigmoid函数，函数的形式见下 正向传播（Forward Propagation）对于上面的式子，重新改写一下第二层的计算：所以不难发现： NN LearningCost Function*注：这里的K是结果分类类别的数量 反向传播————最小化代价函数1）主要思想是先计算最后一层的误差，然后一层层的反向求出各层的误差（至倒数第二层）2）式子最后利用这些计算出来的偏导数就可以按以前的梯度下降法或别的方法来进行计算了 Unrolling Parameters把矩阵换为向量传递例子： Training的步骤注：①初始权重一般设成接近0的很小值","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"},{"name":"神经网络","slug":"神经网络","permalink":"http://oppalu.github.io/tags/神经网络/"}]},{"title":"机器学习related(2) ———— LDA","slug":"机器学习related(2) ———— LDA","date":"2017-10-11T12:39:40.000Z","updated":"2017-10-11T12:41:03.000Z","comments":true,"path":"2017/10/11/机器学习related(2) ———— LDA/","link":"","permalink":"http://oppalu.github.io/2017/10/11/机器学习related(2) ———— LDA/","excerpt":"","text":"基本思想输入分词后的文章集（一篇文章一行，是一个词袋）和主题数K，输出每篇文章的每个词的主题编号、每篇文章的主题概率分布、每个主题下词的概率分布等 LDA相关的前置知识二项分布C(n,k)p^k(1-p)^(n-k) 多项分布 Beta分布————二项分布的共轭先验分布期望是a/a+b dirichlet分布 gamma函数（阶乘在实数范围的扩展） 定义 性质 共轭先验分布先验概率，就是常识、经验所透露出的“因”的概率，后验概率就是在知道“果”之后，去推测“因”的概率。如果后验概率P(θ|x)和先验概率p(θ)满足同样的分布律，那么，先验分布和后验分布被叫做共轭分布，同时，先验分布叫做似然函数的共轭先验分布 LDA的生成过程1.对每一篇文档，从主题分布中抽取一个主题；2.从上述被抽到的主题所对应的单词分布中抽取一个单词；3.重复上述过程直至遍历文档中的每一个单词。 LDA整体流程文档集合D中每个文档d看作一个单词序列，wi表示第i个单词，设d有n个单词。D中涉及的所有不同单词组成一个大集合VOCABULARY（简称VOC），LDA以文档集合D作为输入，希望训练出的两个结果向量（设聚成k个topic，VOC中共包含m个词）：①对每个D中的文档d，对应到不同Topic的概率θd(pt1,…,ptk)，其中，pti表示d对应T中第i个topic的概率。pti=nti/n，其中nti表示d中对应第i个topic的词的数目，n是d中所有词的总数。②对每个T中的topic t，生成不同单词的概率φt(pw1,…,pwm)，其中，pwi表示t生成VOC中第i个单词的概率。pwi=Nwi/N，其中Nwi表示对应到topict的VOC中第i个单词的数目，N表示所有对应到topict的单词总数。LDA的核心公式如下：p(w|d)=p(w|t)p(t|d)直观的看这个公式，*就是可以通过当前的θd和φt给出了文档d中出现单词w的概率。其中p(t|d)利用θd计算得到，p(w|t)利用φt计算得到。 LDA的学习过程LDA算法开始时，先随机地给θd和φt赋值（对所有的d和t）。然后不断重复下面的迭代的学习过程： 针对一个特定的文档ds中的第i单词wi，如果令该单词对应的topic为tj，可以把上述公式改写为：pj(wi|ds)=p(wi|tj)*p(tj|ds) 枚举T中的topic，得到所有的pj(wi|ds)，其中j取值1~k。然后可以根据这些概率值结果为ds中的第i个单词wi选择一个topic。最简单的想法是取令pj(wi|ds)最大的tj 如果ds中的第i个单词wi在这里选择了一个与原先不同的topic，就会对θd和φt有影响了。它们的影响又会反过来影响对上面提到的p(w|d)的计算。对D中所有的d中的所有w进行一次p(w|d)的计算并重新选择topic看作一次迭代。这样进行n次循环迭代之后，就会收敛到LDA所需要的结果了。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"},{"name":"LDA","slug":"LDA","permalink":"http://oppalu.github.io/tags/LDA/"}]},{"title":"机器学习related(1)","slug":"机器学习related(1)","date":"2017-10-10T07:29:29.000Z","updated":"2017-10-10T07:30:18.000Z","comments":true,"path":"2017/10/10/机器学习related(1)/","link":"","permalink":"http://oppalu.github.io/2017/10/10/机器学习related(1)/","excerpt":"","text":"机器学习related(1) 监督学习：通过已有的训练样本（即已知数据以及其对应的输出）来训练，从而得到一个最优模型，再利用这个模型将所有新的数据样本映射为相应的输出结果非监督学习：事先没有任何训练数据样本，需要直接对数据进行建模。 一般m是样本数，n是特征值数，代价函数为J代价函数和梯度下降算法的代数描述 代价函数和梯度下降算法的矩阵算法 加快梯度下降的执行速度—-Feature Scaling思想：将各个feature的值标准化，使得取值范围大致都在-1&lt;=x&lt;=1之间 求最优解除了梯度下降外的方法【n&lt;10000时选择】—-Normal Equation（正规方程）","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"}]},{"title":"关于mac -bash- hexo- command not found的解决","slug":"关于mac -bash- hexo- command not found的解决","date":"2017-04-09T15:36:06.000Z","updated":"2019-02-01T14:56:05.649Z","comments":true,"path":"2017/04/09/关于mac -bash- hexo- command not found的解决/","link":"","permalink":"http://oppalu.github.io/2017/04/09/关于mac -bash- hexo- command not found的解决/","excerpt":"","text":"好久没写博客了，今天提交一下发现突然报了错：-bash: hexo: command not found。这时候就比较懵逼了，然后想了想会不会是环境变量没有配好的原因，结果去查了一下也没有找到网上说的路径下有hexo-cli文件夹，这时候就开始怀疑是不是自己以前安装的时候没有装成全局-g的。。。于是可以考虑重新装，使用npm install -g hexo-cli,这个时候你可能会遇到如下的报错信息：1234567891011121314151617181920212223242526272829npm ERR! tar.unpack untar error /Users/aprildove/.npm/hexo/3.2.2/package.tgznpm ERR! Darwin 15.3.0npm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;hexo&quot; &quot;-g&quot;npm ERR! node v4.4.5npm ERR! npm v2.15.5npm ERR! path /usr/local/lib/node_modules/hexonpm ERR! code EACCESnpm ERR! errno -13npm ERR! syscall mkdirnpm ERR! Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo&apos;npm ERR! at Error (native)npm ERR! &#123; [Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo&apos;]npm ERR! errno: -13,npm ERR! code: &apos;EACCES&apos;,npm ERR! syscall: &apos;mkdir&apos;,npm ERR! path: &apos;/usr/local/lib/node_modules/hexo&apos;,npm ERR! fstream_type: &apos;Directory&apos;,npm ERR! fstream_path: &apos;/usr/local/lib/node_modules/hexo&apos;,npm ERR! fstream_class: &apos;DirWriter&apos;,npm ERR! fstream_stack: npm ERR! [ &apos;/usr/local/lib/node_modules/npm/node_modules/fstream/lib/dir-writer.js:35:25&apos;,npm ERR! &apos;/usr/local/lib/node_modules/npm/node_modules/mkdirp/index.js:47:53&apos;,npm ERR! &apos;FSReqWrap.oncomplete (fs.js:82:15)&apos; ] &#125;npm ERR! npm ERR! Please try running this command again as root/Administrator.npm ERR! Please include the following file with any support request:npm ERR! /Users/aprildove/Workspace/github/npm-debug.log 这个是因为权限不够，加上sudo执行应该就没有问题了。。。然后安装成功后就可以愉快的hexo g和hexo d了为了防止之后可能还有问题可以在环境变量的配置文件中将hexo的环境变量路径加入:12//使用这句打开配置文件sudo vi ~/.bash_profile 在后面加入1/usr/local/lib/node_modules/hexo-cli/bin","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://oppalu.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://oppalu.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"http://oppalu.github.io/tags/github-pages/"}]},{"title":"react+material-ui的一些学习心得（二）","slug":"react+material-ui的一些学习心得（二）","date":"2016-12-29T07:45:16.000Z","updated":"2016-12-29T08:13:28.000Z","comments":true,"path":"2016/12/29/react+material-ui的一些学习心得（二）/","link":"","permalink":"http://oppalu.github.io/2016/12/29/react+material-ui的一些学习心得（二）/","excerpt":"上一篇介绍了一下使用react时的一些工具，这一篇就写写React和material-ui的一些学习笔记吧。同样比较粗糙简略","text":"上一篇介绍了一下使用react时的一些工具，这一篇就写写React和material-ui的一些学习笔记吧。同样比较粗糙简略 React什么是ReactReact 是一个用于构建用户界面的 JavaScript 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 使用npm安装React如果你的系统还不支持 Node.js 及 NPM 可以参考之前的几篇博文然后使用npm安装React的相关包12npm install react --savenpm install react-dom --save 小例子下面用一个简单的小例子来简单的介绍一下jsx，下文会做详细解释App.jsx12345678910111213import React from &apos;react&apos;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello World!!!&lt;br /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 然后引入组件并将其渲染到根元素 App 上123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./App.jsx&apos;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;)) 总的来看，React可自定义组件，如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import 将其导入即可使用。 React JSX使用可以将React JSX 代码可以放在一个独立文件上（js），然后通过下方代码使用1&lt;script type=&quot;text/babel&quot; src=&quot;...&quot;&gt;&lt;/script&gt; React组件要渲染 React 组件，只需创建一个大写字母开头的本地变量。例如12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello World！&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage /&gt;, document.getElementById(&apos;example&apos;)); 其中React.createClass 方法用于生成一个组件类 HelloMessage。React.render()第一个参数为实例化的组件对象，第二个是要放的地方。注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 传递参数如果我们需要向组件传递参数，可以使用 this.props 对象。注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name=&quot;Runoob&quot; /&gt;, document.getElementById(&apos;example&apos;)); 可以通过 getDefaultProps() 方法为 props 设置默认值 Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI 再次强调本文比较简略，具体内容可参见React官方文档 Material-ui这部分参见官方使用文档 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://www.ruanyifeng.com/blog/2015/03/react.htmlhttp://www.runoob.com/react/react-tutorial.htmlhttps://facebook.github.io/react/docs/hello-world.html","categories":[{"name":"React","slug":"React","permalink":"http://oppalu.github.io/categories/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://oppalu.github.io/tags/react/"}]},{"title":"react+material-ui的一些学习心得（一）","slug":"react+material-ui的一些学习心得（一）","date":"2016-12-29T03:28:28.000Z","updated":"2017-05-23T16:27:30.000Z","comments":true,"path":"2016/12/29/react+material-ui的一些学习心得（一）/","link":"","permalink":"http://oppalu.github.io/2016/12/29/react+material-ui的一些学习心得（一）/","excerpt":"因为人机交互课程要对之前的项目进行修改，用了别人的项目使用的是react+material-ui，所以对他们进行了一些简单的学习。这篇博文主要介绍了一下使用react时的一些工具，写的比较简单基本只有一些要点的记录，因为最开始是写给自己看的就比较简略。详细的学习可参见提供的博文地址 npm什么是npmnpm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。","text":"因为人机交互课程要对之前的项目进行修改，用了别人的项目使用的是react+material-ui，所以对他们进行了一些简单的学习。这篇博文主要介绍了一下使用react时的一些工具，写的比较简单基本只有一些要点的记录，因为最开始是写给自己看的就比较简略。详细的学习可参见提供的博文地址 npm什么是npmnpm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 安装npm安装可参见前一篇讲解hexo搭建时的下载方式 使用npm安装模块1npm install xxx -g 注：-g为可选参数，加上表示全局安装 本地安装放在./node_modules中，通过require()引入全局安装放在/usr/local或node的安装目录，直接在命令行使用 关于package.jsonpackage.json文件用来定义包的属性其中dependencies为依赖包列表，如果依赖包没有安装npm会自动安装到node_modules中 webpack什么是webpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 关于webpack的部分建议大家参考这篇博文，属于入门精品 工作方式给定主文件，从它开始找项目的所有依赖文件用loaders处理他们 webpack.config.js是webpack的配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 使用npm执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，直接使用npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, 使用webpack构建本地服务器使用本地服务器可以使得浏览器监测到代码修改并自动刷新修改后的结果，在webpack中进行配置之前需要单独安装它作为项目依赖1npm install --save-dev webpack-dev-server 在devserver的配置选项中inline设为true时源文件改变时会自动刷新页面 loader通过不同的loader，webpack通过调用外部的工具对不同格式的文件进行处理 配置可以使用配置文件中的module，其中： test：一个匹配loaders要处理的文件的拓展名的正则表达式 loader：loader include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹） query：为loaders提供额外的设置选项 例如在我们的项目中就使用babel来处理jsx文件，关于babel介绍参见下文123456789loaders: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: &apos;babel&apos;, query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125;] Babel什么是BabelBabel是一个编译JavaScript的平台，可以编译下一代的JavaScript标准（ES6，ES7）以及基于JavaScript进行了拓展的语言 Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包），使用npm对这些包进行安装 配置则在webpack配置文件的module中（见上文） PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://blog.csdn.net/kun5706947/article/details/52596766http://blog.csdn.net/zccz14/article/details/51421324http://www.runoob.com/nodejs/nodejs-npm.html","categories":[{"name":"React","slug":"React","permalink":"http://oppalu.github.io/categories/React/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://oppalu.github.io/tags/npm/"},{"name":"webpack","slug":"webpack","permalink":"http://oppalu.github.io/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"http://oppalu.github.io/tags/babel/"}]},{"title":"mac下利用hexo+github pages建立个人博客","slug":"mac下利用hexo-github-pages建立个人博客","date":"2016-12-15T11:22:16.000Z","updated":"2019-02-01T14:32:30.501Z","comments":true,"path":"2016/12/15/mac下利用hexo-github-pages建立个人博客/","link":"","permalink":"http://oppalu.github.io/2016/12/15/mac下利用hexo-github-pages建立个人博客/","excerpt":"折腾了一晚上终于搞定了自己的博客，觉得还是要写下来万一之后要重新弄然而zz了都不记得了，也给别的小伙伴做个参考吧~参考了很多博客，在后文会表示感谢的！用到的是hexo和github pages，当然也可以使用Jekyll（而且这个貌似是github官方比较推荐的，但是个人感觉hexo的theme更好看一点2333）废话不说了开始正题","text":"折腾了一晚上终于搞定了自己的博客，觉得还是要写下来万一之后要重新弄然而zz了都不记得了，也给别的小伙伴做个参考吧~参考了很多博客，在后文会表示感谢的！用到的是hexo和github pages，当然也可以使用Jekyll（而且这个貌似是github官方比较推荐的，但是个人感觉hexo的theme更好看一点2333）废话不说了开始正题 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。这里可以参考Hexo的中文官方文档 安装Hexo安装按照文档所给的步骤进行即可，在此列出一些较关键的步骤 安装前提首先确保电脑中已安装了下列应用程序：Node.jsGit 如果没有请根据以下安装指示完成安装： Git使用 Homebrew, 或下载安装程序安装。 Node.js（这里使用nvm来进行安装）首先安装nvm（cURL）:1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js1$ nvm install stable 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 建站安装 Hexo 完成后，在本地新建一个文件夹，并进入到文件夹目录下，执行12hexo init$ npm install 新建完成后，指定文件夹的目录如下：123456├── _config.yml├── package.json├── scaffolds├── source| ├── _posts└── themes 这里主要强调_config.yml，这是你的配置文件，themes文件夹中存放你的主题，source/_posts中存放的是你的博文，可使用markdown等格式 对于theme的使用，Hexo提供了众多模板,使用时将其下载解压至theme文件夹中，然后将_config.yml最后的theme后改成你想要使用的theme名 Github pagesGithub page可以方便的为项目建立介绍站点，也可以用来建立个人博客。 创建代码仓库首先你需要有一个Github账号，这里就不细说了，网上可以找到大量的教程。之后利用Github新建一个项目命名要按照username.github.io的格式，其中username是你的Github账号名 将Hexo部署到Gihub Page将_config.yml最后的deploy部分改成下面的1234deploy:type: gitrepo: https://github.com/username/username.github.io.gitbranch: master 将其中的username改为你自己的Github账号名，这样就部署好了~ Markdown我的博客使用的都是Markdown，Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。 Markdown具有很多优点：写作中添加简单符号即完成排版，所见即所得。让你专注于文字而不是排版。格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf等。Cmd Markdown 的主界面通常一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果 在线编辑工具在这里推荐一个在线Markdown编辑工具作业部落，而这个上传本地图片是要收费的，所以提供一个图床网站，上传本地图片到这里然后使用生成的URL即可[2018update, 图床似乎停止维护了，建议参考教程使用github作图床] 发布新博客利用hexo发布新博客时，使用下面的命令1$ hexo n &quot;new post&quot; 其中new post为文章标题，执行命令后，会在项目\\source_posts中生成new post.md文件，打开编写即可。也可以直接在\\source_posts中新建一个md文件。文件开头可使用下列部分12345title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: example #分类tags: [tag1,tag2,tag3] #文章标签，可空description: 附加一段文章摘要，字数最好在140字以内。 编写完成后，推送到服务器上，执行12$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://www.jianshu.com/p/05289a4bc8b2http://cyzus.github.io/2015/06/21/github-build-blog/https://hexo.io/zh-cn/docs/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://oppalu.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://oppalu.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"http://oppalu.github.io/tags/github-pages/"}]}]}