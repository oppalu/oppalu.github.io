{"meta":{"title":"Phoebe's blog","subtitle":"分享一些学习上的心得经验","description":"高露在Github上的个人博客","author":"Phoebe Gao","url":"http://oppalu.github.io"},"pages":[{"title":"分类","date":"2016-12-15T12:28:06.000Z","updated":"2016-12-15T12:28:36.000Z","comments":true,"path":"categories/index.html","permalink":"http://oppalu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-12-15T12:25:57.000Z","updated":"2016-12-15T12:29:33.000Z","comments":true,"path":"tags/index.html","permalink":"http://oppalu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java并发编程常见问题整理","slug":"Java并发编程常见问题整理","date":"2019-03-04T06:11:45.000Z","updated":"2019-03-14T14:14:40.248Z","comments":true,"path":"2019/03/04/Java并发编程常见问题整理/","link":"","permalink":"http://oppalu.github.io/2019/03/04/Java并发编程常见问题整理/","excerpt":"最近准备面试的时候发现在典型的Java技术类面试中，多线程问题几乎是必考考点会经常被问到。Java内置了对于并发的支持，之前在开发中可能只是简单的用过类似synchronized关键字，但是并不完全了解Java的多线程设计，如其他的并发工具等。复习的时候参考了博客，《Java并发编程实战》以及《操作系统》，整理了一些常见的Java多线程编程的问题与知识点，方便日后自己的复习学习。可能有些地方见解不尽正确，如果有人发现敬请指正:)","text":"最近准备面试的时候发现在典型的Java技术类面试中，多线程问题几乎是必考考点会经常被问到。Java内置了对于并发的支持，之前在开发中可能只是简单的用过类似synchronized关键字，但是并不完全了解Java的多线程设计，如其他的并发工具等。复习的时候参考了博客，《Java并发编程实战》以及《操作系统》，整理了一些常见的Java多线程编程的问题与知识点，方便日后自己的复习学习。可能有些地方见解不尽正确，如果有人发现敬请指正:) 进程与线程的基础知识并发与并行的区别并发：在同一时间间隔内多个任务同时执行。宏观并行，微观串行，单核处理器就可以做到。并行：在同一时刻多个任务同时执行。宏观与微观均并行，多核处理器才可以做到。 进程与线程以及他们的区别进程是具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源调度和分配的独立单位线程是进程中能够并发执行的实体，是进程的组成部分，是处理器调度的基本单位。线程是进程的子集，一个进程可以有很多线程。进程在执行过程中拥有独立的内存空间，而多个线程共享进程的内存。 操作系统的进程调度策略？先来先服务fcfs：每次从就绪队列中选择最先进入的进程优先级调度：从就绪队列中找优先级最高的轮转调度（时间片调度）：每次把cpu分给就绪队列首进程使用规定的时间片，就绪队列的每个进程轮流使用一个时间片，用完后让出cpu并排到就绪队列尾部。多级反馈队列调度算法：建立多个优先级不同的队列，队内fcfs 进程间的通信方式？信号通信机制：通过软中断提供信号的通信机制。管道通信机制：对于管道文件的读写实现。用于具有亲缘关系的进程间的通信，fifo命名管道可在无关进程间交换数据消息队列：使用信箱和发信/收信原语共享内存：使用信号量及其原语操作（PV、读写锁、管程）控制套接字socket 进程的状态运行态running：进程占有处理器正在运行就绪态ready：进程具备运行条件，等待系统分配处理器以便运行（如时间片用完）等待态wait：阻塞/睡眠态，进程不具备运行条件，正在等待某个事件完成（等待时间结束进入就绪态） 线程的状态新建态new：还没开始运行的线程处于这种状态可运行Runnable：可能正在运行，也可能正在等待 CPU 时间片。阻塞Blocked：等待获取一个排它锁[被动]无限期等待Waiting：无限期的等待另一个线程执行特定方法的线程处于这种状态限期等待Timed waiting：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。[主动]终止Terminated：已经退出（运行结束）的线程处于这种状态 进程的同步机制？原子操作，信号量机制，自旋锁，管程 线程的同步方式？互斥量：互斥对象，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。信号量：允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。事件/信号(wait&amp;notify)：通过通知操作的方式来保持多线程同步，允许一个线程在处理完一个任务后，主动唤醒另外一个线程执行任务。 守护线程 唯一用途是为其他线程提供服务(如计时线程, GC线程) 当所有非守护线程结束时，程序也就终止，同时会杀死所有守护线程。 t.setDaemon(true)转换成守护线程。（要在start()之前调用） 线程的使用如何创建线程？继承Thread类覆写父类中的 run() 方法，新线程类创建线程。当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。 实现Runnable接口重写run()方法来定义线程的行为，通过 Thread 调用 start() 方法来启动线程。12345678910public class MyRunnable implements Runnable &#123; public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现Callable接口与 Runnable 相比，Callable 的 call() 方法可以返回值和抛出异常，FutureTask 类构造创建方法体，Thread 类创建线程123456789101112public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; MyCallable mc = new MyCallable(); FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(mc); Thread thread = new Thread(ft); thread.start(); System.out.println(ft.get());&#125; 对比 Thread受限于 Java 的单继承，线程间无法共享变量 实现了Runnable接口的类可在线程间共享，适合于多个线程处理同一个任务的情况。 线程中的常用方法start()在使用 new 关键字创建一个线程后，CPU 并不会执行线程中的代码。只有在 start() 方法执行后，才表示这个线程变成Runnable 态，至于何时真正运行还要看线程调度器的调度 run()当调用 start() 方法启动一个线程时，虚拟机会将该线程放入就绪队列中等待被调度，当一个线程被调度时会执行该线程的 run() 方法。如果直接调用 run() 方法，就会被当做普通方法来使用。 join()把指定的线程加入到当前线程，可以将两个交替执行的线程合并为顺序执行的线程。比如在线程B中调用了线程A的Join()方法，直到线程A执行完毕后，才会继续执行线程B。 sleep()主动放弃占用的处理器资源，该线程进入阻塞状态，指定的睡眠时间超时后，线程进入就绪状态等待线程调度器的调用。 yield()主动放弃占用的处理器资源，线程直接进入就绪状态等待线程调度器的调用。 Executor框架框架图下图是Executor框架常用接口与子类的框架图： Executor：定义了一个接收Runnable对象的方法execute(Runnable command) ExecutorService：是一个比Executor使用更广泛的子类接口，其提供了生命周期管理的方法，以及可跟踪一个或多个异步任务执行状况返回Future的方法 AbstractExecutorService：ExecutorService执行方法的默认实现 ScheduledExecutorService：一个可定时调度任务的接口 ScheduledThreadPoolExecutor：ScheduledExecutorService的实现，一个可定时调度任务的线程池 ThreadPoolExecutor：线程池，可以通过调用Executors的静态工厂方法来创建线程池并返回一个ExecutorService对象 线程池使用线程池的优点： 避免了不断创建和销毁线程导致的性能开销。 当请求到达时，工作线程通常已经存在，不会由于等待线程创建而延迟任务的执行，从而提高了响应性。 可有效控制最大并发线程数，防止过多线程相互竞争资源而使应用程序耗尽内存或失败。通过Executors可以创建哪些线程池？ newFixedThreadPool：创建一个定长线程池，每当提交一个任务就创建一个线程，直到达到线程池的最大数量。 newCachedThreadPool：创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。 newSingleThreadExecutor：是一个单线程的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照队列中指定顺序(FIFO, LIFO, 优先级)执行。如果异常会创建另一个线程来代替。 newScheduledThreadPool：创建一个定长线程池，支持定时及周期性任务执行。（多数情况下可用来替代Timer类。） Executor简介 Executor提供了一种标准的方法管理多个异步任务的执行，将任务的提交过程和执行过程解耦开发，基于生产者-消费者模式，其提交任务的线程相当于生产者，执行任务的线程相当于消费者。 “在线程池中执行任务”： 对于实现Runnable接口的对象，执行器通过execute方法将任务提交到工作队列中，工作线程反复的从工作队列中取出任务并执行12345678//examplepublic static void main(String[] args) &#123; ExecutorService executorService = Executors.newCachedThreadPool(); for (int i = 0; i &lt; 5; i++) &#123; executorService.execute(new MyRunnable()); &#125; executorService.shutdown();&#125; 执行过程 如果线程池的大小小于配置的corePoolSize，说明还可以创建新线程，则启动新的线程执行这个任务。 如果线程池的大小大于配置的corePoolSize，会把任务加入任务队列即可。如果任务队列不满(即放入成功)，则提交的任务在任务队列中等待处理；否则则需要考虑是否要扩展线程池的容量。 当线程池已经关闭或者上面的条件都不能满足时，则进行拒绝策略，拒绝策略在RejectedExecutionHandler接口中定义 中断interrupt() 通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。 调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程 不能中断 I/O 阻塞和 synchronized 锁阻塞。1234567891011121314151617public class InterruptExample &#123; private static class MyThread2 extends Thread &#123; @Override public void run() &#123; while (!interrupted()) &#123; // .. &#125; System.out.println(&quot;Thread end&quot;); &#125; &#125;&#125;public static void main(String[] args) throws InterruptedException &#123; Thread thread2 = new MyThread2(); thread2.start(); thread2.interrupt();&#125; Executor的中断操作 调用 Executor 的 shutdown() 方法会等线程都执行完毕之后再关闭，但是如果调用的是 shutdownNow() 方法，则相当于调用每个线程的 interrupt() 方法。 线程的互斥同步锁机制synchronized 是JVM实现的内置锁。是一种互斥锁，最多只有一个线程能持有这种锁。 可用于同步一个代码块，一个方法，一个类等 12345678910111213public void func() &#123; synchronized (this) &#123; // ... &#125;&#125;public synchronized void func () &#123; // ...&#125;public void func() &#123; synchronized (SynchronizedExample.class) &#123; // ... &#125;&#125; 线程进入同步代码块之前自动获得锁，退出时自动释放[释放前会将修改的变量同步更新到内存中] 可重入，即锁的粒度是线程而非调用[一个线程可以获得自己已经持有的锁，用一个计数值，再次获得时递增退出递减0时释放]显式锁 lock()&amp;unlock() ReentrantLock： java.util.concurrent包中的锁，保证任何时刻只有一个线程进入临界区 ReentrantLock 可中断，而 synchronized 不行 synchronized与ReentrantLock对比 synchronized 是 JVM 实现的，而 ReentrantLock 是 JDK 实现的。 公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。synchronized 中的锁是非公平的，ReentrantLock 默认情况下也是非公平的，但是也可以是公平的。 当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情。ReentrantLock 可中断，而 synchronized 不行。 一个 ReentrantLock 可以同时绑定多个 Condition 对象。 wait() notify() notifyAll() wait()：使一个线程处于等待（阻塞）状态，并且释放所持有的对象的锁； notify()：唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关； notityAll()：唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它们竞争，只有获得锁的线程才能进入就绪状态； 它们都属于 Object 的一部分，而不属于 Thread。 await(), signal(), signalAll() java.util.concurrent 类库中提供了 Condition 类来实现线程之间的协调，在 Condition 上调用 await()方法使线程等待，其它线程调用 signal()或 signalAll()方法唤醒等待的线程。 相比于 wait() 这种等待方式，await() 可以指定等待的条件，因此更加灵活。 J.U.C工具类闭锁相当于门，闭锁到达结束状态前门一直关闭，并且没有任何线程能通过。到达时允许所有线程通过 CountDownLatch 用来控制一个线程等待多个线程。 维护了一个计数器cnt，每次调用countDown()方法会让计数器的值减1。await()方法会等待计数器达到0(表示所有需要等待的事件都已经发生)，然后唤醒等待的线程。 CyclicBarrier 用来控制多个线程互相等待，只有当多个线程都到达时，这些线程才会继续执行。（闭锁用于等待事件，栅栏用于等待其他线程） 和 CountdownLatch 相似，都是通过维护计数器来实现的。线程执行await()方法之后计数器会减1，并进行等待，直到计数器为0，所有调用await()方法而在等待的线程才能继续执行。 CyclicBarrier 和 CountdownLatch 的一个区别是，CyclicBarrier 的计数器通过调用 reset() 方法可以循环使用，所以它才叫做循环屏障。 Semaphore 类似于操作系统中的信号量，可以控制对互斥资源的访问线程数。 有acquire()和release()方法 FutureTask 既可以当做一个任务执行，也可以有返回值 可用于异步获取执行结果或取消执行任务的场景。当一个计算任务需要执行很长时间，那么就可以用 FutureTask 来封装这个任务，主线程在完成自己的任务之后再去获取结果。1234567891011121314151617FutureTask&lt;Integer&gt; futureTask = new FutureTask&lt;Integer&gt;(new Callable&lt;Integer&gt;() &#123; @Override public Integer call() throws Exception &#123; int result = 0; //长时间计算 for (int i = 0; i &lt; 100; i++) &#123; Thread.sleep(10); result += i; &#125; return result; &#125; &#125;); Thread computeThread = new Thread(futureTask); computeThread.start(); //先做完别的逻辑 System.out.println(futureTask.get()); BlockingQueue 提供了阻塞的 take() 和 put() 方法：如果队列为空 take()将阻塞，直到队列中有内容；如果队列为满 put()将阻塞，直到队列有空闲位置。 FIFO 队列：LinkedBlockingQueue、ArrayBlockingQueue（固定长度） 优先级队列：PriorityBlockingQueue 线程安全不可变Immutable 一定是线程安全的 final, String, enum, Number部分子类(Long, Double, BigInteger) 无共享数据 栈封闭：访问局部变量，因为局部变量在栈中是线程私有的 ThreadLocal：为变量在每个线程中都创建了一个副本，那么每个线程可以访问自己内部的副本变量 存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递 线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收 在Thread类中有一个Map，用于存储每一个线程的变量的副本。 volatile变量 确保将变量的更新操作通知到其他线程 一旦某个线程修改了该被volatile修饰的变量，它会保证修改的值会立即被更新到主存。当有其他线程需要读取时，volatile变量总会返回最新写入的值 使用条件：对变量的写入操作不依赖变量的当前值；该变量不会与其他状态变量一起纳入不变性条件；访问变量时不需要加锁 Java内存模型先行发生原则 单一线程原则：在一个线程内，在程序前面的操作先行发生于后面的操作 管程锁定原则：一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile变量规则：对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则：Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 线程加入规则：Thread 对象的结束先行发生于 join() 方法返回。 线程中断规则：对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 对象终结规则：一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性：如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 锁优化自旋锁在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。但是它需要进行忙循环操作占用 CPU 时间，只适用于共享数据的锁定状态很短的场景。 锁消除锁消除是指对于被检测出不可能存在竞争的共享数据的锁进行消除。锁消除主要是通过逃逸分析来支持，如果堆上的共享数据不可能逃逸出去被其它线程访问到，那么就可以把它们当成私有数据对待，也就可以将它们的锁进行消除。 轻量级锁使用 CAS 操作来避免重量级锁使用互斥量的开销。对于绝大部分的锁，在整个同步周期内都是不存在竞争的，因此也就不需要都使用互斥量进行同步，可以先采用 CAS 操作进行同步，如果 CAS 失败了再改用互斥量进行同步。 注：CAS是单词compare and set的缩写，意思是指在set之前先比较该值有没有变化，只有在没变的情况下才对其赋值。（类似乐观锁） 偏向锁偏向锁的思想是偏向于让第一个获取锁对象的线程，这个线程在之后获取该锁就不再需要进行同步操作，甚至连 CAS 操作也不再需要。当有另外一个线程去尝试获取这个锁对象时，偏向状态就宣告结束，此时撤销偏向（Revoke Bias）后恢复到未锁定状态或者轻量级锁状态。 多线程开发的良好实践 给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。如对于 synchronized，应尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%B9%B6%E5%8F%91.mdhttp://www.importnew.com/12773.html","categories":[{"name":"Java","slug":"Java","permalink":"http://oppalu.github.io/categories/Java/"}],"tags":[{"name":"Java 并发 多线程","slug":"Java-并发-多线程","permalink":"http://oppalu.github.io/tags/Java-并发-多线程/"}]},{"title":"高级算法设计与分析技术——动态规划","slug":"高级算法设计与分析技术","date":"2019-02-14T02:24:28.000Z","updated":"2019-03-01T12:10:46.656Z","comments":true,"path":"2019/02/14/高级算法设计与分析技术/","link":"","permalink":"http://oppalu.github.io/2019/02/14/高级算法设计与分析技术/","excerpt":"做算法题的时候遇到过很多动态规划相关的问题，但是了解了大致的解法却没有仔细的学习过动态规划的知识。想着单纯的做算法题不如了解解体的通法重要，就结合着《算法导论》一书和一些相关的博客内容整理了包括动态规划在内的一些高级算法设计与分析技术。只是自己学习的笔记，可能有些地方见解不尽正确，如果有人发现敬请指正:)","text":"做算法题的时候遇到过很多动态规划相关的问题，但是了解了大致的解法却没有仔细的学习过动态规划的知识。想着单纯的做算法题不如了解解体的通法重要，就结合着《算法导论》一书和一些相关的博客内容整理了包括动态规划在内的一些高级算法设计与分析技术。只是自己学习的笔记，可能有些地方见解不尽正确，如果有人发现敬请指正:) 动态规划原理概述动态规划应用于子问题重叠的情况，即不同的子问题具有公共的子子问题。动态规划的核心在于记住已经解决过的子问题的解，利用查表代替调用函数递归。分治的话会反复的求解公共的子子问题，而动态规划对每个子子问题只求解一次，将其解保存在一个表格中，从而无需每次求解一个子子问题时都重新计算动态规划一般会用来解决最优化问题，即求问题的最优解 应用动态规划方法求解最优化问题应具备两个要素：最优子结构和子问题重叠。 最优子结构用动态规划法求解最优化问题的第一步就是刻画最优解的结构。如果一个问题的最优解包含其子问题的最优解，则该问题具有最优子结构性质。 子问题重叠子问题空间必须足够小，即问题的递归算法会反复的求解相同的子问题而不是一直产生新的子问题。动态规划对每个子问题求解一次，就将解存入一个表中，当再次需要这个子问题时直接查表，每次查表的代价为常量时间。 动态规划算法的两种形式由上面可知动态规划算法的核心是记住已经求过的解，记住的方法有自底向上和带备忘的自顶向下算法两种。我用最简单的斐波那契问题为例 带备忘的自顶向下算法它的思路在于创建一个数组来保存每次计算的子问题的解。 对于斐波那契问题而言，就是创建了一个n+1大小的数组来保存求出的斐波拉契数列中的每一个值，在递归的时候如果发现前面fib（n）的值计算出来了就不再计算，如果未计算出来，则计算出来后保存在数组中，下次在调用fib（n）的时候就不会重新递归了。 自底向上通常自底向上使用最优子结构。即首先求子问题的最优解，然后根据子问题得到原问题的最优解。对于斐波那契问题而言，就是先计算出fib（1），fib（2），fib（3）等并保存下来，再计算原问题的解。 例子：钢条切割问题上图是算法导论里的一道例题。用这个问题来对上面的解法做一些更直观的理解。 一般的递归算法递归算法思路比较容易理解，就不进行介绍。由于有大量重复计算递归效率较低。12345678910public static int cut(int []p,int n)&#123; if(n==0) return 0; int q=Integer.MIN_VALUE; for(int i=1;i&lt;=n;i++) &#123; q=Math.max(q, p[i-1]+cut(p, n-i)); &#125; return q;&#125; 带备忘的自顶向下算法备忘算法也很容易理解，就是在递归的时候保存每次已经运行过的子问题的结果。1234567891011121314151617181920public static int cutMemo(int []p)&#123; int []r=new int[p.length+1]; for(int i=0;i&lt;=p.length;i++) r[i]=-1; return cut(p, p.length, r);&#125;public static int cut(int []p,int n,int []r)&#123; int q=-1; if(r[n]&gt;=0) return r[n]; if(n==0) q=0; else &#123; for(int i=1;i&lt;=n;i++) q=Math.max(q, cut(p, n-i,r)+p[i-1]); &#125; r[n]=q;//保存每次的结果 return q;&#125; 自底向上自底向上的思路比较难理解，关键在于中间的二层for循环。外面的循环是求r1,r2……，里面的循环是求出r1,r2……的最优解，也就是说r[i]中保存的是钢条长度为i时划分的最优解，这里面涉及到了最优子结构问题，也就是一个问题取最优解的时候，它的子问题也一定要取得最优解。12345678910public static int buttom_up_cut(int []p)&#123; int []r=new int[p.length+1]; for(int i=1;i&lt;=p.length;i++)&#123; int q=-1; for(int j=1;j&lt;=i;j++) q=Math.max(q, p[j-1]+r[i-j]); r[i]=q; &#125; return r[p.length];&#125; PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://blog.csdn.net/u013309870/article/details/75193592","categories":[{"name":"算法","slug":"算法","permalink":"http://oppalu.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://oppalu.github.io/tags/动态规划/"}]},{"title":"JVM学习笔记(4)——JAVA类加载机制","slug":"JVM学习笔记-4-——JAVA类加载机制","date":"2019-02-12T12:13:55.000Z","updated":"2019-03-13T08:19:15.583Z","comments":true,"path":"2019/02/12/JVM学习笔记-4-——JAVA类加载机制/","link":"","permalink":"http://oppalu.github.io/2019/02/12/JVM学习笔记-4-——JAVA类加载机制/","excerpt":"上一篇介绍了Java class文件的存储格式。在class文件中描述的各种信息最终都需要加载到虚拟机中才能被运行和使用。而虚拟机如何加载这些class文件，class文件进入虚拟机后又会发生什么变化？本篇笔记就会结合《深入理解Java虚拟机》一书的第7章内容作简要的介绍。","text":"上一篇介绍了Java class文件的存储格式。在class文件中描述的各种信息最终都需要加载到虚拟机中才能被运行和使用。而虚拟机如何加载这些class文件，class文件进入虚拟机后又会发生什么变化？本篇笔记就会结合《深入理解Java虚拟机》一书的第7章内容作简要的介绍。 Java程序的执行过程参见JVM学习笔记1 类的生命周期Java中，类是在运行期间第一次使用时动态加载的，而不是一次性加载。类的整个生命周期包括：加载（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）7个阶段。其中验证、准备和解析3个部分统称为连接(Linking)。加载、验证、准备、初始化和卸载的顺序是确定的，而解析阶段某些情况下可在初始化阶段后再开始(运行时的动态绑定)。 类初始化的时机主动引用虚拟机规范中严格规定了有且只有下列五种情况必须对类进行初始化（加载、验证、准备都会随之发生）。这5种场景中的行为称为对一个类进行主动引用： 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时。生成这4条指令的最常见的Java代码场景是：使用new关键字实例化对象的时候，读取或设置一个类的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）的时候，以及调用一个类的静态方法的时候。 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化。 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。 当使用JDK 1.7动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果REF_getStatic、REF_putStatic、REF_invokeStatic的方法句柄，并且该方法句柄所对应的类没有初始化过，则先触发初始化。 被动引用所有引用类的方式都不会触发初始化，称为被动引用。被动引用的常见例子包括： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value); // value 字段在 SuperClass 中定义, SubClass不会初始化 通过数组定义来引用类，不会触发此类的初始化。（该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。） 1SuperClass[] sca = new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化 1System.out.println(ConstClass.HELLOWORLD) 类加载的过程加载：查找并加载类的二进制数据加载阶段，虚拟机需要完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将这个字节流所代表的静态存储结构转化为方法区的运行时存储结构。 在内存中生成一个代表这个类的 Class 对象，作为方法区这个类的各种数据的访问入口。 其中二进制字节流可以从以下方式中获取： 从 ZIP 包读取，成为 JAR、EAR、WAR 格式的基础。 从网络中获取，最典型的应用是 Applet。 运行时计算生成，例如动态代理技术，在 java.lang.reflect.Proxy 使用 ProxyGenerator.generateProxyClass 的代理类的二进制字节流。 由其他文件生成，例如由 JSP 文件生成对应的 Class 类。 验证：确保被加载的类的正确性验证是连接阶段的第一步，目的是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。验证阶段大致会完成下面4个阶段的检验动作： 文件格式验证：即验证字节流是否符合Class文件格式规范 元数据验证：对字节码描述信息进行语义分析，以保证其描述的信息符合Java语言规范的要求(如是否有父类，是否继承了不允许继承的类，是否实现了父类或接口中要求实现的所有方法等) 字节码验证：最复杂，通过数据流和控制流分析，确定程序语义的合法性和逻辑性。（如跳转指令不会跳到方法体之外，方法体中类型转换有效等） 符号引用验证：发生在解析阶段，可看做是对类自身以外的信息进行匹配性校验，目的保证解析动作能正常执行，如果无法通过符号引用验证，则会抛出异常。(如访问性级别等) 准备：为类的静态变量分配内存并初始化准备阶段是正式为类变量分配并设置类变量初始值的阶段，这些内存都将在方法区中进行分配。实例变量不会在这阶段分配内存，它将会在对象实例化时随着对象一起分配在堆中。这里所说的初始值“通常情况”是数据类型的零值12345//value在准备阶段过后的初始值为0而不是1,而把value赋值的putstatic指令将在初始化阶段才会被执行。public static int value = 1;//此时准备阶段value赋值为1public static final int value = 1; 解析：把类中的符号引用转换为直接引用解析阶段是将常量池的符号引用替换为直接引用的过程。解析动作主要针对类或接口、字段、类方法、接口方法、方法类型、方法句柄和调用点限定符7类符号引用进行。符号引用就是一组符号来描述目标，可以是任何字面量。直接引用是直接指向目标的指针，相对偏移量或是一个能间接定位到目标的句柄。直接引用和虚拟机实现的内存有关，同一个符号引用在不同虚拟机实例上翻译出来的直接引用不尽相同。 初始化初始化阶段才真正开始执行类中定义的 Java 程序代码。初始化阶段即虚拟机执行类构造器 &lt; clinit&gt;() 方法的过程。在准备阶段，类变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划去初始化类变量和其它资源。 &lt; clinit&gt;() 是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的，编译器收集的顺序由语句在源文件中出现的顺序决定。特别注意的是，静态语句块只能访问到定义在它之前的类变量，定义在它之后的类变量只能赋值，不能访问。例如以下代码：1234567public class Test &#123; static &#123; i = 0; // 给变量赋值可以正常编译通过 System.out.print(i); // 这句编译器会提示“非法向前引用” &#125; static int i = 1;&#125; 由于父类的 &lt; clinit&gt;() 方法先执行，也就意味着父类中定义的静态语句块的执行要优先于子类。例如以下代码：1234567891011121314static class Parent &#123; public static int A = 1; static &#123; A = 2; &#125;&#125;static class Sub extends Parent &#123; public static int B = A;&#125;public static void main(String[] args) &#123; System.out.println(Sub.B); // 2&#125; &lt; clinit&gt;() 方法不是必须的，如果没有静态语句块和赋值操作就可以没有。 接口中不可以使用静态语句块，但仍然有类变量初始化的赋值操作，因此接口与类一样都会生成 &lt; clinit&gt;() 方法。但接口与类不同的是，执行接口的 &lt; clinit&gt;() 方法不需要先执行父接口的 &lt; clinit&gt;() 方法。 虚拟机会保证一个类的 &lt; clinit&gt;() 方法在多线程环境下被正确的加锁和同步，如果多个线程同时初始化一个类，只会有一个线程执行这个类的 () 方法，其它线程都会阻塞等待，直到活动线程执行 () 方法完毕。 类加载器比较两个类相等，只有在这两个类使用同一个类加载器进行加载的前提下才有意义。这是因为每一个类加载器都拥有一个独立的类名称空间。 类的加载类加载有三种方式： 命令行启动应用时候由JVM初始化加载 通过Class.forName()方法动态加载 通过ClassLoader.loadClass()方法动态加载 类加载器种类从JVM角度，只存在两种不同的类加载器：启动类加载器和其他的。细分可如下： 启动类加载器(Bootstrap ClassLoader)使用 C++ 实现，是虚拟机自身的一部分负责将存放在 &lt; JRE_HOME &gt;\\lib 目录中的，或者被 -Xbootclasspath 参数所指定的路径中的，并且是虚拟机识别的（仅按照文件名识别，如 rt.jar，名字不符合的类库即使放在 lib 目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被 Java 程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给启动类加载器，直接使用 null 代替即可。 扩展类加载器（Extension ClassLoader）由 ExtClassLoader（sun.misc.Launcher$ExtClassLoader）实现的。它负责将 &lt; JAVA_HOME &gt;/lib/ext 或者被 java.ext.dir 系统变量所指定路径中的所有类库加载到内存中，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader）由 AppClassLoader（sun.misc.Launcher$AppClassLoader）实现的。由于这个类加载器是 ClassLoader 中的 getSystemClassLoader() 方法的返回值，因此一般称为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型应用程序都是由三种类加载器相互配合进行加载的，如果有必要，还可以加入自己定义的类加载器。上图展示的类加载器之间的层次关系，称为类加载器的双亲委派模型（Parents Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都要有自己的父类加载器。这里类加载器之间的父子关系一般通过组合（Composition）关系来实现，而不是通过继承（Inheritance）的关系实现。 工作过程如果一个类加载器收到了类加载的请求，它会首先将类加载请求传送到父类加载器，只有当父类加载器无法完成类加载请求时才尝试自己加载。 优点使得 Java 类随着它的类加载器一起具有一种带有优先级的层次关系，从而使得基础类得到统一。无论那个类加载器要加载这个类，最终都是委托给处于模型最顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。（防止内存中出现多份同样的字节码） 实现1234567891011121314151617181920212223242526protected Class&lt;?&gt; loadClass(String name, boolean resolve) throws ClassNotFoundException &#123; synchronized (getClassLoadingLock(name)) &#123; // 首先检查请求的类是否已经被加载过了 Class&lt;?&gt; c = findLoadedClass(name); if (c == null) &#123; try &#123; if (parent != null) &#123; c = parent.loadClass(name, false); &#125; else &#123; c = findBootstrapClassOrNull(name); &#125; &#125; catch (ClassNotFoundException e) &#123; //如果父类加载器抛出异常说明父类加载器无法完成加载请求 &#125; if (c == null) &#123; // 父类无法加载调用自身的findClass方法进行类加载 c = findClass(name); &#125; &#125; if (resolve) &#123; resolveClass(c); &#125; return c; &#125; &#125; PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md#%E5%9B%9B%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6http://www.cnblogs.com/ityouknow/p/5603287.htmlhttps://blog.csdn.net/w760079528/article/details/77845267","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JVM学习笔记(3)——JAVA类文件结构与执行引擎","slug":"JVM学习笔记-3-——JAVA类文件结构","date":"2019-02-09T10:32:07.000Z","updated":"2019-03-13T08:53:07.304Z","comments":true,"path":"2019/02/09/JVM学习笔记-3-——JAVA类文件结构/","link":"","permalink":"http://oppalu.github.io/2019/02/09/JVM学习笔记-3-——JAVA类文件结构/","excerpt":"前面大概介绍了JVM的运行时数据区域以及JVM的垃圾回收和内存分配策略，这一篇主要是针对书中第6章内容整理JAVA的类文件结构。Java语言的特点在于跨平台，通过将源文件编译成与操作系统无关的，只有虚拟机能识别并执行的字节码文件，由各个操作系统上的jvm来负责执行，屏蔽了底层具体的操作系统。这一篇主要就是介绍一下这个字节码文件的性质，为之后介绍Java的类加载机制做好预备知识。","text":"前面大概介绍了JVM的运行时数据区域以及JVM的垃圾回收和内存分配策略，这一篇主要是针对书中第6章内容整理JAVA的类文件结构。Java语言的特点在于跨平台，通过将源文件编译成与操作系统无关的，只有虚拟机能识别并执行的字节码文件，由各个操作系统上的jvm来负责执行，屏蔽了底层具体的操作系统。这一篇主要就是介绍一下这个字节码文件的性质，为之后介绍Java的类加载机制做好预备知识。 Class类文件结构class文件是一组以8位字节为基础的二进制流，其与Java虚拟机指令集和符号表以及若干其他辅助信息相对应。各个数据项严格按照顺序紧凑的排列在class文件中，中间没有添加任何分隔符，使得整个class文件中存储的文件几乎都是程序运行的必要数据。 整体结构class文件采用了类似C语言结构体的形式来存储数据，由无符号数和表两种数据结构组成 无符号数：是class文件基本的数据类型，用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节、8个字节的无符号数。 表：是由无符号数或者其他表作为数据项构成的复合数据类型，以_info 结尾。用于描述有层次关系复合结构的数据整体上看，类文件整体结构如下图所示，具体每项在后文介绍。 文件数据项用一个简单的例子来介绍class文件。Test.java123456789package org.tianbin.clazz;public class Test&#123; private int m; public int inc()&#123; return m + 1; &#125;&#125; Test.class12345678910111213CA FE BA BE 00 00 00 34 00 13 0A 00 04 00 0F 09 00 03 00 10 07 00 11 07 00 12 01 00 01 6D 01 00 01 49 01 00 06 3C 69 6E 69 74 3E 01 00 03 28 29 56 01 00 04 43 6F 64 65 01 00 0F 4C 69 6E 65 4E 75 6D 62 65 72 54 61 62 6C 65 01 00 03 69 6E 63 01 00 03 28 29 49 01 00 0A 53 6F 75 72 63 65 46 69 6C 65 01 00 09 54 65 73 74 2E 6A 61 76 61 0C 00 07 00 08 0C 00 05 00 06 01 00 16 6F 72 67 2F 74 69 61 6E 62 69 6E 2F 63 6C 61 7A 7A 2F 54 65 73 74 01 00 10 6A 61 76 61 2F 6C 61 6E 67 2F 4F 62 6A 65 63 74 00 21 00 03 00 04 00 00 00 01 00 02 00 05 00 06 00 00 00 02 00 01 00 07 00 08 00 01 00 09 00 00 00 1D 00 01 00 01 00 00 00 05 2A B7 00 01 B1 00 00 00 01 00 0A 00 00 00 06 00 01 00 00 00 03 00 01 00 0B 00 0C 00 01 00 09 00 00 00 1F 00 02 00 01 00 00 00 07 2A B4 00 02 04 60 AC 00 00 00 01 00 0A 00 00 00 06 00 01 00 00 00 07 00 01 00 0D 00 00 00 02 00 0E 魔数1CA FE BA BE //class文件的头4个字节（咖啡baby2333） 魔数是用来确定文件是否是一个能够被虚拟机接受的class文件。由于文件扩展名可以随意改动，因此只靠文件扩展名来确定文件类型并不可靠。 主次版本号100 00 00 34 魔数后4个字节，第5个和第6个字节是次版本号，第7个和第8个字节是主版本号（从45开始）。虚拟机可以向下兼容运行class文件，但不能运行高于其版本的class文件。 常量池结构：容量计数器（u2类型）+ 常量容量计数器从1开始，目的是满足某些常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池”的含义。例子中00 13，表示有12项常量(索引范围为1-12) 常量池中存放两大类常量： 字面量（Literal）: 类似Java中的常量，如文本字符串，声明为final的常量值等。 符号引用（Symbolic References）：包括类和接口的全限定名（Full Qualified Name）,字段的名称和描述符（Descriptor），方法的名称和描述符这三类常量。 常量池中每一项常量都是一个表，共有14种常量表类型，所有常量表开始第一位为u1类型的标志位，标识常量类型。读取常量池的时候首先读取标志位，判断常量类型，就可以知道对应的结构，获取对应的信息了。下图展示了14种常量的具体类型和对应的标志位：每种类型的结构如下（其中u1表示1个字节，u2表示2个字节，其他类似）：示例中的常量池示例可参见附录中的参考博客1 访问标志常量池之后两个字节标识类的访问标志，用于识别一些类或者接口层次的访问信息，即这个class是类还是接口，是否为public等信息。具体标志位及标志含义见下图 类索引、父类索引、接口索引12300 03 类索引 //org/tianbin/clazz/Test00 04 父类索引 //java/lang/Object 00 00 接口索引集合大小 类索引、父类索引都是一个u2类型的数据。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名。它们会对应到常量池中的CONSTANT_Class_info类描述符常量，通过常量中的索引值就可以找到定义在CONSTANT_Utf8_info类的全限定名字符串。接口索引集合是一组u2类型的数据的集合。第一项u2类型的数据为接口计数器，表示接口索引表的容量，之后的每两个字节表示一个接口索引，用法同类索引与父类索引。 字段表集合1234500 01 fields_count00 02 access_flags00 05 name_index //m00 06 descriptor_index00 00 attributes_count 字段表用于描述接口或者类中声明的变量，包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段表使用标志位表示修饰符，引用常量池中的常量描述字段名及字段数据类型。access_flags可以设置的标志位和含义见下图name_index代表字段的简单名称。descriptor_index代表字段和方法的描述符。对于字段来说用来描述字段的数据类型；而对于方法来说，描述的就是方法的参数列表（包括数量、类型以及顺序）和返回值。具体如下图所示： 方法表集合100 02 method_count //&lt;init&gt; inc class文件中对方法的描述与以前对字段的描述几乎完全一致的方式，唯一的区别就是访问类型不完全一致。方法标志具体见下： 属性表集合Class文件、字段表、方法表都可以有自己的属性表集合，用于描述某些场景的专有信息。符合规范的属性表基本结构如下：其中前两个字节为指向常量池中的CONSTANT_Utf8_info类型的属性名称，之后4个字节表示属性值所占用的位数，最后就是具体属性了。 在具体属性中，列举几个比较重要的，剩下的可自行查阅《深入理解JVM》一书： Code属性用来存储Java程序方法体中的代码经过编译处理后生成的字节码指令。每个指令是一个u1类型的单字节，共可以表达256条指令。 Exception属性用于列举方法中可能抛出的受查异常 SourceFile属性该属性是一个定长属性，用于记录生成这个Class文件的源码文件名称 执行引擎方法调用作用是确定被调用方法的版本(即调用哪一个方法) 解析分派(重载与重写) 静态分派：依赖静态类型来定位方法执行版本，发生在编译阶段。典型是方法重载。 动态分派：与重写有很大关系。 在方法区中维护一个虚方法表来存放各个方法的实际入口地址。如果方法在子类中没有被重写，则子类虚方法表中的地址入口与父类一致均指向父类的实现入口，否则会替换为子类的。 基于栈的字节码解释执行引擎基于操作栈完成解释过程 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://tb-yangshu.github.io/2017/05/11/java_bytecode_structure/#morehttps://www.cnblogs.com/zawier/p/6659311.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JVM学习笔记(2)——垃圾回收机制与内存分配策略","slug":"JVM学习笔记-2-——垃圾回收机制与内存分配策略","date":"2019-02-06T07:29:35.000Z","updated":"2019-03-13T08:08:20.628Z","comments":true,"path":"2019/02/06/JVM学习笔记-2-——垃圾回收机制与内存分配策略/","link":"","permalink":"http://oppalu.github.io/2019/02/06/JVM学习笔记-2-——垃圾回收机制与内存分配策略/","excerpt":"上一篇博客主要介绍了Java的内存区域模型。这篇主要根据书中第3章内容和一些博客介绍一下Java的垃圾回收机制和内存分配策略。由于在Java的运行数据区中，程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，随线程而生，随线程而灭，在方法结束或线程结束时，内存自然就跟着回收了，不需要过多考虑回收的问题。而Java堆和方法区是共享的，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这两者。","text":"上一篇博客主要介绍了Java的内存区域模型。这篇主要根据书中第3章内容和一些博客介绍一下Java的垃圾回收机制和内存分配策略。由于在Java的运行数据区中，程序计数器、虚拟机栈、本地方法栈三个区域都是线程私有的，随线程而生，随线程而灭，在方法结束或线程结束时，内存自然就跟着回收了，不需要过多考虑回收的问题。而Java堆和方法区是共享的，这部分内存的分配和回收都是动态的，垃圾回收器关注的是这部分内存，后续讨论的“内存”分配回收也是指这两者。 垃圾收集判断哪些对象应被回收引用计数算法主要思路：为对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。问题：难以解决对象之间相互循环引用的问题。在两个对象出现循环引用的情况下，引用计数器永远不为 0，导致无法对它们进行回收。1234567891011public class Test &#123; public Object instance = null; public static void main(String[] args) &#123; Test a = new Test(); Test b = new Test(); a.instance = b; b.instance = a; &#125;&#125; 正因为循环引用的存在，因此Java虚拟机不使用引用计数算法。 可达性分析算法主要思路：通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的。Java中可作为GC Roots的对象包括以下几种： 虚拟机栈中局部变量表中引用的对象 方法区中类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中Native方法引用的对象 finalize()宣告对象死亡的两次标记过程： 没有与GC Roots相连接的引用链则被第一次标记并进行一次筛选，筛选条件为是否有必要执行该对象的finalize方法。若对象没有覆盖finalize方法或者该finalize方法是否已经被虚拟机执行过了，则均视作不必要执行该对象的finalize方法，即该对象将会被回收。反之，若对象覆盖了finalize方法并且该finalize方法并没有被执行过，那么，这个对象会被放置在一个叫F-Queue的队列中。 对F-Queue中对象进行第二次标记，如果对象在finalize方法中拯救了自己，即关联上了GC Roots引用链，如把this关键字赋值给其他变量，那么在第二次标记的时候该对象将从“即将回收”的集合中移除，如果对象还是没有拯救自己，那就会被回收。由于对象的finalize方法最多被虚拟机调用一次，因此它只能拯救自己一次。 回收方法区方法区的垃圾回收主要回收两部分内容：1. 废弃常量。2. 无用的类。 废弃常量：类似于回收Java堆中的对象 无用的类：满足以下三个条件的无用类可以被回收(不是一定，可以通过配置参数来控制是否对类进行回收) 该类所有的实例都已经被回收，此时堆中不存在该类的任何实例 加载该类的 Class Loader 已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。 引用类型1.强引用：只要强引用还存在，垃圾收集器就不会回收掉被引用的对象，通常使用new一个新对象的方式来创建强引用。1Object obj = new Object(); 2.软引用：描述还有用但非必需对象。在内存不够的情况下会被回收。Java中的类SoftReference表示软引用。123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 3.弱引用：描述非必需对象。被弱引用关联的对象只能生存到下一次垃圾回收之前，垃圾收集器工作之后，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。Java中的类WeakReference表示弱引用。4.虚引用：一个对象是否有虚引用的存在，不会对其生存时间造成影响，也无法通过虚引用得到一个对象。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。Java中的类PhantomReference表示虚引用。 垃圾收集算法(内存回收的方法论)标记-清除算法首先标记出所有需要回收的对象，标记完成后统一回收所有被标记的对象(标记可参考前文finalize部分)缺点： 标记和清除过程效率都不高 会产生大量不连续的内存碎片，导致无法给大对象分配内存。 复制算法将可用的内存分为两块，每次只用其中一块，当这一块内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已经使用过的内存空间一次性清理掉。这样每次只需要对整个半区进行内存回收，内存分配时也不需要考虑内存碎片等复杂情况，只需要移动指针，按照顺序分配即可。缺点：内存缩小为了原来的一半代价较高现在的商业虚拟机都采用这种收集算法回收新生代，但是并不是划分为大小相等的两块，而是一块较大的 Eden 空间和两块较小的 Survivor 空间，每次使用 Eden 和其中一块 Survivor。在回收时，将 Eden 和 Survivor 中还存活着的对象全部复制到另一块 Survivor 上，最后清理 Eden 和使用过的那一块 Survivor。 标记-整理算法复制算法在对象存活率较高的场景下要进行大量的复制操作，效率很低。万一对象100%存活，那么需要有额外的空间进行分配担保。老年代都是不易被回收的对象，对象存活率高，因此一般不能直接选用复制算法。根据老年代的特点，有人提出了另外一种标记-整理算法，过程与标记-清除算法一样，不过不是直接对可回收对象进行清理，而是让所有存活对象都向一端移动，然后直接清理掉边界以外的内存。： 分代收集算法根据对象存活周期将内存划分为几块，不同块采用适当的收集算法。一般将堆分为新生代和老年代。 新生代(大批对象死去、少量对象存活的)：复制算法 老年代(对象存活率高、没有额外空间进行分配担保的)：“标记-清除”或“标记-整理”算法 垃圾收集器(内存回收的具体实现)上图展示了7种垃圾收集器，连线表示垃圾收集器可以配合使用。 Serial收集器Serial收集器是一个单线程的收集器，只会使用一个线程进行垃圾收集工作。它进行垃圾收集时必须暂停其他线程的所有工作，直到它收集结束为止。（Stop the world，难以接受）优点在于简单高效，是虚拟机运行在Client模式下的默认新生代收集器。 ParNew收集器是Serial的多线程版本。是 Server 模式下首选的新生代收集器，除了性能原因外，主要是因为除了 Serial 收集器，只有它能与 CMS 收集器配合工作。 Parallel Scavenge收集器是使用复制算法的并行的多线程收集器。是虚拟机运行在Server模式下的默认垃圾收集器。其他收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量（吞吐量=运行用户代码时间/（运行用户代码时间+垃圾收集时间））。因此也被称为“吞吐量优先收集器”停顿时间短适合需要与用户交互的程序，良好的响应速度能提升用户体验；高吞吐量则可以高效率利用CPU时间，尽快完成运算任务，主要适合在后台运算而不需要太多交互的任务。 Serial Old收集器Serial收集器的老年代版本，同样是一个单线程收集器，使用“标记-整理算法”，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。 Parallel Old收集器是 Parallel Scavenge 收集器的老年代版本。在注重吞吐量以及 CPU 资源敏感的场合，可以优先考虑 Parallel Scavenge 加 Parallel Old 收集器。 CMS收集器与用户线程并发执行CMS（Concurrent Mark Sweep）是一种使用标记-清除算法，以获取最短回收停顿时间为目标的收集器。适合用于互联网等重视服务的响应速度，希望系统停顿时间最短的情况。整个过程分为4个步骤： 初始标记：仅仅是标记一下 GC Roots 能直接关联到的对象，速度很快，需要STW 并发标记：进行 GC Roots Tracing 的过程，它在整个回收过程中耗时最长，不需要STW 重新标记：为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要STW 并发清除：回收内存空间，时间很长,不需要STW 缺点： 吞吐量低：低停顿时间是以牺牲吞吐量为代价的，导致 CPU 利用率不够高。 无法处理浮动垃圾，因为在并发清理阶段用户线程还在运行，自然就会产生新的垃圾，而在此次收集中无法收集他们，只能留到下次收集，这部分垃圾为浮动垃圾 由于采用的标记 - 清除算法，会产生大量的内存碎片，不利于大对象的分配，可能会提前触发一次Full GC。 G1收集器(jdk1.7出现)是一款面向服务端应用的垃圾收集器，在多 CPU 和大内存的场景下有很好的性能。可直接对新生代和老年代一起回收。 G1引入 Region 的概念，将原来的一整块内存空间划分成多个的小空间，使得每个小空间可以单独进行垃圾回收 特点： 并行和并发：使用多个CPU来缩短Stop The World停顿时间，与用户线程并发执行。 分代收集 空间整合：整体来看是基于“标记 - 整理”算法实现的收集器，从局部（两个 Region 之间）上来看是基于“复制”算法实现的，这意味着运行期间不会产生内存空间碎片。 可预测的停顿：能让使用者明确指定在一个长度为 M 毫秒的时间片段内，消耗在 GC 上的时间不得超过 N 毫秒。 主要步骤： 初始标记 并发标记 最终标记：为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。这阶段需要停顿线程，但是可并行执行。 筛选回收：首先对各个 Region 中的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间来制定回收计划。此阶段其实也可以做到与用户程序一起并发执行，但是因为只回收一部分 Region，时间是用户可控制的，而且停顿用户线程将大幅度提高收集效率。 内存分配与回收策略垃圾回收模式 Minor GC: 回收新生代，因为新生代对象存活时间很短，因此 Minor GC 会频繁执行，执行的速度一般也会比较快。【当Eden 空间满时触发】 Major GC/Full GC: 指发生在老年代的GC，出现Major GC，经常会伴随至少一次Minor GC。老年代对象其存活时间长，因此 Full GC 很少执行，执行速度会比 Minor GC 慢很多。触发条件见下： 调用 System.gc()【不建议使用，让虚拟机管理内存】 老年代空间不足 空间分配担保失败 Concurrent Mode Failure：执行 CMS GC 的过程中同时有对象要放入老年代，而此时老年代空间不足便会报 Concurrent Mode Failure 错误，并触发 Full GC。 内存分配规则：对象优先在Eden分配对象通常在新生代的Eden区进行分配，当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC 大对象直接进入老年代大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。大对象的出现会导致提前触发垃圾收集以获取更大的连续的空间来进行大对象的分配。-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 区和 Survivor 区之间的大量内存复制。 长期存活的对象将进入老年代虚拟机为每个对象定义了一个对象年龄计数器。对象出生在Eden区、经过一次Minor GC后仍然存活，并能够被Survivor容纳，设置年龄为1，对象在Survivor区每次经过一次Minor GC，年龄就加1，当年龄达到一定程度（默认15），就晋升到老年代，-XX:MaxTenuringThreshold 用来定义年龄的阈值。 动态对象年龄判定虚拟机并不是永远地要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的。否则进行Full GC。 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.mdhttps://blog.csdn.net/zp522123428/article/details/53635161https://www.cnblogs.com/xiaoxi/p/6486852.htmlhttps://www.cnblogs.com/xiaoxi/p/6557473.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JVM学习笔记(1)——内存区域","slug":"JVM学习笔记-1-——内存区域","date":"2019-02-05T12:33:52.000Z","updated":"2019-03-13T08:52:02.553Z","comments":true,"path":"2019/02/05/JVM学习笔记-1-——内存区域/","link":"","permalink":"http://oppalu.github.io/2019/02/05/JVM学习笔记-1-——内存区域/","excerpt":"之前断断续续的看JVM，这次打算从头完整的学习一遍《深入理解JAVA虚拟机》一书，并利用博客把学习过程记录下来。这篇主要根据书中第2章内容和一些博客介绍一下JAVA的内存区域划分的相关知识。","text":"之前断断续续的看JVM，这次打算从头完整的学习一遍《深入理解JAVA虚拟机》一书，并利用博客把学习过程记录下来。这篇主要根据书中第2章内容和一些博客介绍一下JAVA的内存区域划分的相关知识。 JVM简介JVM即Java Virtual Machine，JAVA程序实际上就是交由JVM执行，我们先来看看JVM的大致组成 组成从上图可以看出，JVM由四大块组成：Class Loader类加载器，JVM运行时数据区，执行引擎和本地接口。这里简单的介绍一下各个部分，虚拟机执行子系统的具体内容会在后续JVM相关的博客中进行介绍。 Class Loader类加载器，主要负责查找，加载，解析 字节码文件(.class后缀)到JVM内存区，以供JVM执行引擎执行加载的字节码。 JVM运行时数据区，具体将在后文进行介绍 执行引擎主要是把可解释的代码，解释为操作系统机器码。当字节码文件被加载到内存后变成了JVM可解释的代码，JVM执行引擎就负责执行这些代码来完成相应的任务。 本地接口主要是把不同语言实现的方法提供给Java调用。 编译过程Javac编译器完成程序源码经过词法分析、语法分析形成抽象语法树，然后遍历语法树生成线性的字节码指令流。 执行过程 首先Java源代码文件(.java后缀)会被Java编译器编译为字节码文件(.class后缀)。每个java程序都需要运行在自己的JVM上，并告知 JVM 程序的运行入口 然后JVM中的Class Loader(类加载器)会加载各个类的字节码文件，加载完毕之后，交由JVM中的执行引擎执行。 在整个程序执行过程中，JVM会用一段空间来存储程序执行过程中需要用到的数据和相关信息，这段空间一般被称作为Runtime Data Area（运行时数据区），也就是我们常说的JVM内存。 运行时数据区域如上图所示，Java虚拟机所管理的内存包括程序计数器，Java虚拟机栈，本地方法栈，方法区，Java堆和运行时常量池几个运行时数据区域，其中方法区和堆由所有线程共享，剩下三个是线程隔离的数据区（如下图示例）。即JVM在初始运行的时候会分配好方法区和堆，之后JVM 每遇到一个线程，就为其分配一个程序计数器，Java虚拟机栈和本地方法栈。 程序计数器程序计数器是一块较小的内存区域，作用是记录当前正在执行的虚拟机字节码指令的地址(如果执行的是Native方法则值为空)。虚拟机在执行字节码时，通过改变PC的值来选择下一条需要执行的字节码指令。每个线程需要有自己独立的程序计数器是为了确保多线程情况下线程切换后可以恢复到正确的执行位置（各线程之间计数器互不影响独立存储）。 Java虚拟机栈Java虚拟机栈描述了Java方法执行的内存模型。每个 Java 方法在执行的同时会创建一个栈帧(Stack frame)用于存储局部变量表(包含了对应的方法参数【基本数据类型+对象引用】和局部变量)、操作数栈(实际上就是通过不断地进栈出栈进行计算)、动态连接、方法返回地址等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。 这个区域有两种异常情况： 如果线程请求的栈深度大于虚拟机容许的最大深度，将抛出StackOverflowError异常 如果虚拟机栈可以动态扩展，但是扩展时无法申请到足够的内存，抛出OutOfMemoryError异常。 本地方法栈本地方法栈与 Java 虚拟机栈类似，区别在于虚拟机栈为执行Java方法服务，本地方法栈为执行Native方法服务(参见上文JVM结构图) Java堆Java堆是虚拟机管理的内存中最大的一块，由所有线程共享。Java堆主要用于存放对象实例，成员变量(非静态)以及数组，所有对象都在这里分配内存。对象实例在堆中分配好以后，要在Java虚拟机栈中保存一个4字节的堆内存地址，用来定位该对象实例在堆中的位置，便于找到该对象实例。Java堆是垃圾回收的主要区域，也被成为“GC”堆。（关于垃圾回收会在之后的博客中进行介绍）。堆不需要物理上的连续内存，只要逻辑上连续即可，并且可以动态增加其内存，增加失败会抛出 OutOfMemoryError 异常。 新生代与老年代如上图所示，堆被划分成两个不同的区域：新生代 ( Young ) 和老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。这样划分的目的是为了使 JVM 能够更好的管理堆内存中的对象，包括内存的分配以及回收。 老年代老年代存放的都是存活时间较久的，大小较大的对象(通常约为堆容量的2/3)。使用标记整理算法。当年老代容量满的时候，会触发一次Major GC（full GC）。 EdenEden位于Java堆的年轻代，是新对象分配内存的地方。默认情况下Edem : from : to = 8 :1 : 1 SurvivorSurvival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。 方法区方法区也是各个线程共享的内存区域，用于存储已经被虚拟机加载的类信息（包括类的名称、方法信息、字段信息）、常量、静态变量、即时编译器编译后的代码等数据。这个区域也会存在垃圾回收，不过回收的目标主要是针对常量池的回收和对类型的卸载，但是一般比较难实现。在JVM规范中，没有强制要求方法区必须实现垃圾回收。HotSpot 虚拟机把它当成永久代来进行垃圾回收。当无法申请到足够的内存时会抛出OutOfMemoryError异常。 运行时常量池是方法区的一部分。在Class文件中除了类的字段、方法、接口等描述信息外，还有一项是常量池用来存储编译期间生成的字面量和符号引用，这部分会在类加载后被放入这个区域。运行时产生的新常量也可以被放入常量池中，比如 String 类中的 intern() 方法产生的常量。 直接内存直接内存不受JVM管理，它使用native函数库直接分配堆外内存，然后通过存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在堆内存和堆外内存来回拷贝数据。动态扩展时也可能出现OutOfMemoryError异常。 对象的访问定位对于堆中对象的访问主要有使用句柄和直接指针两种访问方式： 句柄访问会划分一块内存作为句柄池，栈的reference存储句柄地址，句柄包含对象实例数据和类型数据的地址。好处在于对象被移动时栈的reference本身不需要修改。 直接指针访问中，栈的reference存储对象的地址，对象中包含类型数据的地址。好处是速度更快。 JVM调用实例参见博客https://www.cnblogs.com/hellocsl/p/3969768.html?utm_source=tuicool&amp;utm_medium=referral中给的调用示例 OutOfMemoryError异常 Java堆溢出：不断创建对象造成(提示Java heap space) 虚拟机栈和本地方法栈溢出：栈深度过深，扩展栈内存不够 方法区和运行时常量池溢出：运行大量的类(提示permGen space) 直接内存溢出 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://www.cnblogs.com/hellocsl/p/3969768.html?utm_source=tuicool&amp;utm_medium=referralhttps://www.cnblogs.com/dolphin0520/p/3613043.htmlhttps://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E8%99%9A%E6%8B%9F%E6%9C%BA.md","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://oppalu.github.io/tags/JVM/"}]},{"title":"JAVA集合相关整理","slug":"JAVA集合相关整理","date":"2019-02-03T15:34:07.000Z","updated":"2019-03-12T08:31:55.448Z","comments":true,"path":"2019/02/03/JAVA集合相关整理/","link":"","permalink":"http://oppalu.github.io/2019/02/03/JAVA集合相关整理/","excerpt":"概述下面两张图所示是JAVA的集合框架图，从整体上可以发现JAVA容器主要包括了Collection和Map两种。List， Queue和Set集合共同继承Collection这个父接口，Map集合是单独的一个接口。","text":"概述下面两张图所示是JAVA的集合框架图，从整体上可以发现JAVA容器主要包括了Collection和Map两种。List， Queue和Set集合共同继承Collection这个父接口，Map集合是单独的一个接口。 Collection ListList的每一个位置按照索引位置摆放，像一个柜子一层一层的，可以有重复的元素(根据索引找元素) ArrayList：基于动态数组实现,支持随机访问。 Vector：和ArrayList类似，但它是线程安全的。(开销也比 ArrayList 要大，访问速度更慢，因此要避免使用) LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表任何位置插入和删除元素。此外，LinkedList 还可以用作栈、队列和双向队列。 SetSet的每个元素不按顺序进行排序，无序不重复 HashSet：基于哈希表实现，是无序的，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 TreeSet：基于红黑树实现，是有序的，但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 Queue PriorityQueue：基于堆结构实现，可用它来实现优先队列。 MapMap中的每一个元素都是按照键值对的方式存储，一个键对应一个值，键不可以重复，值可以重复，我们可以根据键找到值，也是无序的集合。 HashMap基于哈希表实现，对键进行散列，较快 TreeMap基于红黑树实现，用键的整体顺序对元素进行排序，将其组织成搜索树 HashTable与HashMap类似，区别在于HashMap线程不安全，键最多一个为null值可以为多个null。而HashTable线程安全，键与值都不能为null。（它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全） LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 源码简单分析ArrayList（基于数组实现） 默认大小为10，当容量不够需要扩容时为原来的1.5倍。扩容操作需要调用 Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 由于基于数组实现，删除元素时复杂度为O(N) Fail-fast：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。ArrayList使用一个变量modCount来记录结构发生变化的次数(即添加/删除元素时)，在进行序列化或者迭代等操作时，需要比较操作前后modCount是否改变，如果改变了需要抛出ConcurrentModificationException异常。 Vector 实现与ArrayList类似，但是使用了synchronized进行同步。 每次扩容请求其大小的 2 倍空间 由于效率较低，如果需要同步可以使用Collections.synchronizedList()得到一个线程安全的 ArrayList,或者concurrent并发包下的 CopyOnWriteArrayList 类。12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); CopyOnWriteArrayList concurrent并发包下的类 实现了读写分离，读操作在原始数组上进行，写操作在一个复制的数组上进行，写操作需要加锁(ReetrantLock)，写操作结束后需要把原始数组指向新的复制数组。 适用于读多写少的应用场景。 缺陷在于：写操作需要复制数组使得内存占用。此外读操作不能读到实时性的数据(写操作的数据还未同步到读数组中) LinkedList(基于双向链表实现) 内部节点Node定义了前指针prev和后指针next12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; HashMap(链表+数组) Java定义了一个叫Entry的结构用来存储键值对。它是一个链表，包含了key, value, hashCode, next指针四个字段 Java定义了一个Entry类型的数组table。他的每个位置是一个桶，一个桶存放了一个Entry链表，同一个链表中存放哈希值相同的 Entry。 当插入一个键值对时，先计算K的hashcode，使用除留余数法得到所在的桶下标(如hashCode为115，HashMap大小为16，则得到桶的下标为115%16=3)。 当查找时，先根据hashCode计算键值对所在的桶，然后在对应的链表上顺序查找，时间复杂度和链表的长度成正比。 HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，因此使用第 0 个桶存放键为 null 的键值对。 hash的实现：是通过 hashCode() 的高 16 位异或低 16 位实现的：(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16) 扩容resize() 设 HashMap 的 table 长度为 M，需要存储的键值对数量为 N 参数： capacity: table的默认大小(16)，必须为2^n size: 键值对数量 threshold: size的临界值，size &gt;= threshold的时候就要进行扩容 loadFactor: 装载因子，即table能够使用的比例(默认0.75)，threshold = capacity*loadFactor 需要扩容时，capacity为原来的两倍 要重新计算桶下标：(假设原来是16，现在是32，若原key在第5位是0则不变，否则是原来的key+16) HashMap在并发环境下使用中最为典型的一个问题，就是在HashMap进行扩容重哈希时导致Entry链形成环。一旦Entry链中有环，势必会导致在同一个桶中进行插入、查询、删除等操作时陷入死循环。 HashTable 与HashMap类似，使用 synchronized 来进行同步。不能插入键为null的Entry。 HashMap 需要重新计算 hash 值，而 HashTable 直接使用对象的 hashCode 不建议在新代码中使用，不需要线程安全的场合可以用HashMap替换，需要线程安全的场合可以用ConcurrentHashMap替换。(HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞) ConcurrentHashMap 如图所示，ConcurrentHashMap本质上是一个Segment数组，而一个Segment实例又包含若干个桶，每个桶中都包含一条由若干个 HashEntry 对象链接起来的链表。多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高。 而HashTable 使用一把锁（锁住整个链表结构）处理并发问题，多个线程竞争一把锁，容易阻塞 此外通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作； LinkedHashMap 继承自HashMap 内部维护了一个双向链表，用来维护插入顺序 适合在需要输出的顺序和输入的顺序相同的情况下。 其他 TreeSet：实现SortMap接口，能够把它保存的记录根据键排序（默认按键值升序排序，也可以指定排序的比较器）。适合于需要按照自然顺序或自定义顺序遍历键的情况下。HashSet是通过HashMap来实现的而TreeSet是通过TreeMap来实现的，因此这里不过多介绍 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA集合","slug":"JAVA集合","permalink":"http://oppalu.github.io/tags/JAVA集合/"}]},{"title":"J2EE复习整理","slug":"Java Web","date":"2018-03-12T07:34:45.000Z","updated":"2019-03-14T13:32:25.431Z","comments":true,"path":"2018/03/12/Java Web/","link":"","permalink":"http://oppalu.github.io/2018/03/12/Java Web/","excerpt":"","text":"HTTP状态码 2开头表示成功处理了请求的状态代码(200：请求成功) 3开头表示重定向 4开头表示请求出错(401未授权，403服务器拒绝服务，404找不到资源) 5开头表示服务器内部出错(500服务器内部错误) GET&amp;POST get一般用于从服务器上获取数据，post一般用于向服务器传送数据 请求的时候参数的位置有区别，get的参数是拼接在url后面，用户在浏览器地址栏可以看到。post是放在http包的包体中。 能提交的数据有区别，get方式能提交的数据只能是文本，且大小不超过1024个字节，而post还可以提交二进制文件。 servlet在处理请求的时候分别对应使用doGet和doPost方式进行处理请求 Http请求的URL组成部分包括哪些元素？各表示什么内容？URL组成：http://[host]:[port][request path]?[query string]Request路径 上下文路径（Context path）：/+ Web应用的上下文根目录。 servlet路径（servlet path）：/+与激活该请求的组件别名 路径信息（path info）：/+请求路径的部分，不是上下文路径或者servlet路径的部分。 J2EEJ2EE组件 客户端程序和applets是运行在客户端的组件. java servlet 和jsp技术是运行在服务器端的服务器组件. EJB技术是运行在服务器端的商务逻辑组件. 一个JavaWeb应用的请求处理流程 客户端发送一个 HTTP 请求到 web 服务器。 实现了 Java Servlet 和 JSP 技术的 web 服务器将请求转换为 HTTPServletRequest 对象。 这个对象被交给 web 组件，该组件可以和 JavaBeans 组件或数据库交互从而生成动态内容。 然后 web 组件可能生成一个 HTTPServletResponse，也可能将此请求转发给另一个 web 组件。 web 组件最后生成一个 HTTPServletResponse 对象。 web 服务器将这个对象转换成一个 HTTP response，然后将它返回给客户端。 Web容器 Web组件运行在Web容器上，容器提供了请求分派、安全(可配置)、并发(多线程管理)、生命周期管理等功能。 Tomcat组件 Server: 代表一个服务器，可包含多个Service Service：可包含一个Engine，多个Connector Connector: 在某个指定端口上侦听客户请求，并将请求交给Engine处理 Engine: 将获得的请求匹配到某个虚拟主机上，把请求交给host处理 Host: 每个和网络域名匹配，每个可部署多个Web应用(对应不同的Context) Context: 对应一个Web应用 web.xml: 创建时根据其载入Servlet类。获得请求后查询映射表找到被请求的Servlet类，并执行以获得请求回应。 Tomcat处理http请求的过程 请求被发送到本机端口8080，被Java HTTP Connector获得； Connector将该请求交给它所在的Service的Engine来处理，并等待Engine的回应； Engine获得请求，匹配所有虚拟主机； Engine匹配到名为localhost的主机； localhost主机获得请求，匹配所拥有的所有Context； localhost主机匹配到路径为/HelloWorld的Context； 路径为/HelloWorld的Context获得请求，在映射表中寻找对应的Servlet； Context匹配到URL PATTERN为/的Servlet; 构造HttpServletRequest对象和HttpServletResponse对象，作为参数调用该Servlet的Service方法； Context把执行完之后的HttpServletResponse对象返回给localhost主机； Host把HttpServletResponse对象返回给Engine； Engine把HttpServletResponse对象返回给Connector； Connector把HttpServletResponse对象返回给客户Browser。 EJB Session Bean三种状态 Stateful Session Bean：代表了一个唯一的client与bean的一次会话，不共享。 Stateless Session Bean：bean不保存与client的交互状态，只在一个方法调用的范围内维护client的信息，调用结束后状态消除。 Singleton Session Bean：对每个应用只实例化一次，并存在于整个应用的生命周期内。 Servlet基本定义 定义：是Java编写的服务器端程序。其主要功能在于交互式地浏览和修改数据，生成动态Web内容。是所有web应用技术的基础 任务：读取客户端（浏览器）发送的显式的数据，读取客户端（浏览器）发送的隐式的 HTTP 请求数据，处理数据并生成结果，发送显式的数据（即文档）到客户端（浏览器），发送隐式的 HTTP 响应到客户端（浏览器） 开发HttpServlet步骤 扩展HttpServlet类（使用@WebServlet注解,并指定映射的URL模式） 调用init()方法进行初始化 定制service()：重写 doGet 或 doPost 方法，[而不是service()] 在Web.xml中配置新的Servlet[,通过URL中的url-pattern匹配寻找对应名字的servlet，然后对应处理] Servlet生命周期： 调用init()方法进行初始化 调用service()来处理客户端的请求。每次服务器接收到一个 Servlet 请求时，服务器会产生一个新的线程并调用服务。service() 方法检查 HTTP 请求类型（GET、POST、PUT、DELETE等），在适当的时候调用 doGet、doPost等方法。不用对service()方法做任何动作，只需要根据来自客户端的请求类型来重写 doGet() 或 doPost() 即可。 调用destroy()方法终止 Servlet体系结构 Servlet ServletConfig：获得配置属性 ServletRequest ServletResponse ServletContext：包含Web应用的配置信息，Servlet需要的某些外部资源所在位置等 Servlet处理请求与响应的流程 客户端在浏览器的地址栏中输入一个请求的URL,按回车后就向服务器端发起一个http request(由浏览器生成)。 服务器端的Web Server首先接受到请求，并将请求转交给容器 容器会根据URL,到web.xml中对Servlet的描述去查找要访问的Servlet，若找到，将此Servlet装载进虚拟机并实例化(第一次访问)，然后调用Servlet实例中的service方法处理请求，并分配一个线程去执行。 若没有查找到，直接返回一个404的错误代码到客户端，表示访问的资源不存在。 处理完，HttpServletResponse对象负责将信息返回给客户端[设置HTTP状态码, HTTP响应头， HTTP消息体等] 4种作用域对象 Application：作用域为应用程序运行期，工程启动后存在，当容器关闭时被销毁； Session：作用域为会话期，从打开一个浏览器窗口开始，关闭窗口，会话关闭，当会话超时，被销毁； Request：作用域为用户请求期，只要Server向客户端输出内容，就被销毁； Page：作用域为页面执行期 Servlet线程安全问题 默认多线程 实现 SingleThreadModel 接口(service方法不会有两个线程同时执行) 使用synchronized 关键字同步对共享数据的操作 避免在Servlet方法里使用实例变量 Servlet session跟踪 cookies: 一个 Web 服务器可以分配一个唯一的 sessionID 作为每个 Web 客户端的 cookie，使用cookie识别 隐藏的表单字段 URL重写: [reponse.encodeURL(URL)方法]在每个 URL 末尾追加一些额外的数据来标识 session 会话 cookie&amp;session cookie是服务器将一些数据存在客户端上，下次访问时传给服务器，服务器从而判断是哪个客户。适用于跟踪会话，长期“记住用户信息”，存储在本地计算机硬盘上 session将数据只保存在服务器，生成一个sessionId传给客户端，只是通过cookie传递一个sessionId。 区别： 安全性：cookie数据存放在客户的浏览器上，对客户端可见，可被客户端复制、修改，不安全，session 存储在服务器上，对客户端是透明，更安全 有效期：cookie 可长久储存信息，session 不能长久储存信息，如果超时时间设置过长， 会导致服务器内存溢出（因为保存在服务器上占用服务器性能） 大小限制：单个cookie保存的数据不能超过4K（有大小限制） 转发（forward）和重定向（redirect）的区别？ forward()是RequestDispatcher对象的方法，是服务器容器中控制权的转向。服务器直接访问目标地址的URL，再把响应内容发给浏览器，浏览器不知道服务器发送的内容是从哪儿来的，所以它的地址栏中还是原来的地址 sendRedirect()是HttpServletResponse对象的方法，是客户端跳转，因此从浏览器的地址栏中可以看到跳转后的链接地址 JSP什么是JSP？在传统的网页HTML（标准通用标记语言的子集）文件(.htm,.html)中插入Java程序段(Scriptlet)和JSP标记(tag)，从而形成JSP文件，后缀名为(*.jsp)。可以轻松创建含有静态与动态web组件的web内容 JSP与Servlet的区别与联系 联系：JSP是Servlet技术的扩展，本质上就是Servlet的简易方式。运行时JSP先被编译成”类servlet”。 区别：1)jsp侧重于页面显示,servlet更侧重于逻辑控制2)Servlet完全是JAVA程序代码构成，jsp由HTML代码和JSP标签构成[html中嵌入java] (Servlet的应用逻辑是在Java文件中，并且完全从表示层中的HTML里分离开来。而JSP是Java和HTML组合成一个扩展名为.jsp的文件。) JPA实体类四种状态 new：通过new生成一个实体对象，通过JVM获得了一块内存空间，但是并没有保存进数据库 managed：纳入JPA EntityManager管理中的对象，在数据库中存在一条与它对应的记录，并拥有一个持久化标识 detached：游离对象，脱离了JPA EntityManager的管理，对游离对象的操作不影响数据库。 removed：remove()方法，删除数据库中的记录在适当的时候被垃圾回收 SpringSpring是什么？为什么要用Spring？ 为了解决企业应用开发的复杂性而创建的, 简化Java开发 优点：1)通过依赖注入等实现松耦合，方便开发2)基于AOP进行声明式编程 3)方便集成各种优秀的框架 IocIoc即控制反转(inverse of control)，就是将原本在程序中手动创建对象的控制权，交由Spring框架来管理。 Bean管理相关术语 BeanDefinition：用于管理各种对象以及它们之间相互依赖关系的核心数据结构。 Resource：资源 BeanWrapper：封装一个bean的行为，提供了设置和获取单个Bean的属性值、获取属性信息等功能 作用域scope：singleton表示全局只有一个实例（默认），prototype表示每次被注入的时候都要重新创建一个实例。 IoC容器 BeanFactory：负责创建并维护Bean实例。将系统配置和依赖关系从代码中独立出来。从配置文件中读取类名、属性名，然后通过反射机制进行Bean加载和属性设置。 可配置：Bean属性值与依赖关系，Bean的创建模式，Bean初始化和销毁方法 可通过getBean()获得指定bean的引用 ApplicationContext：是BeanFactory的子接口之一，功能多[支持AOP，支持统一的资源加载，国际化]。会自动解析我们配置的applicationContext.xml 标识一个应用环境，利用BeanFactory创建Bean对象，保存对象关系表，捕获各种事件。 ApplicationContext初始化时会检验属性是否注入，而BeanFactory第一次使用时未注入会跑异常 Spring的依赖注入方式 setter注入(值注入) 构造注入：没有设值注入的情况下才会根据配置文件中的构造注入，一旦有设值注入，则构造注入失效 注解定义完成依赖注入： @Autowired: Spring 会根据类型去IoC容器使用反射寻找定义的 Bean 然后将其注入。按类型注入 @Resource: 按照bean的名字来进行注入的，如果我们没有在使用@Resource时指定bean的名字，同时Spring容器中又没有该名字的bean,这时候@Resource就会退化为@Autowired即按照类型注入 Spring bean的定义方式 在XML中显式定义: 在Java中显式定义 基于注解的bean定义: 要定义扫描 @Component注解：表示 Spring IoC 会把这个类扫描成一个 bean 实例 @ComponentScan注解：代表进行扫描，默认是扫描当前包的路径，扫描所有带有 @Component 注解的 POJO。 IOC容器的初始化(refresh()) Resource定位：即对资源文件的定位。由ResourceLoader通过统一的Resource接口完成。 载入：通过BeanDefinitionReader来完成Bean定义信息的解析，把用户定义好的Bean表示成IOC容器的内部数据结构，即BeanDefinition 注册：由BeanDefinitionRegistry实现的registerBeanDefiition方法进行。将BeanDefinition注入到HashMap中，IOC容器就是通过这个HashMap来管理数据。 IOC容器的依赖注入过程依赖注入的过程是用户第一次向IoC容器索要Bean时触发的，lazy-init属性默认情况下设置的是初始化时就注入。调用getBean()也会注入 从缓存获取当前beanName，看当前类型的bean是否已经被创建过 如果创建过，就从当前BeanFactory中获取bean, 如果当前工厂取不到，就从双亲beanFactory中取，一直进行迭代查找。 如果没有创建过就根据BeanDefinition创建一个bean。递归创建当前bean所依赖的所有bean，然后根据scope创建实例 返回bean Bean的生命周期 简单来说：实例化-&gt;设置属性-&gt;设置Bean名称-&gt;预处理(初始化前)-&gt;初始化Bean-&gt;预处理(初始化后)-&gt;Bean已准备好-&gt;销毁 具体来说： 实例化一个Bean（由BeanFactory读取BeanDefinition，并生成各个实例）——也就是我们常说的new； 按照Spring上下文定义对实例化的Bean设置属性值 ——也就是IOC注入； 如果这个Bean实现了BeanNameAware接口，会调用它实现的setBeanName(String)方法。——获得了自己在配置文件中的id 如果这个Bean实现了BeanFactoryAware接口，会调用它实现的setBeanFactory(BeanFactory)。——获得自己所在的BeanFactory 如果这个Bean实现了ApplicationContextAware接口，会调用setApplicationContext(ApplicationContext)方法。——获得了自己所在的ApplicationContext 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization()进行预初始化 如果Bean类实现了InitializingBean接口，则执行其afterPropertiesSet()方法。 如果Bean声明了初始化方法，则调用该初始化方法。 如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization()进行后初始化。——此时就可以正式使用该bean了 当Bean不再需要时，如果Bean实现了DisposableBean接口，则会调用destroy()方法； 最后，如果这个Bean有自定义的销毁方法，也会调用。 AOP将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。 基本术语 通知Advice：需要的功能，如事务管理等 连接点JoinPoint：允许使用通知的点，如一个方法前/后/抛出异常时 切入点Pointcut：定义在哪通知，即描述某一类选定的连接点。（选定在哪使用通知） 切面Aspect：通知+切入点，即定义在哪里通知，通知什么 目标对象Target：即被AOP动态代理的目标对象 实现 实现核心是动态代理：为需要的业务逻辑生成代理类。代理拦截被通知方法的调用再把调用转发给真正的目标bean 生成代理的方式： ProxyFactoryBean：通过在IoC容器中完成声明式配置 ProxyFactory：通过编程式的方式 AspectJProxyFactory：集成AspectJ 事务Spring事务处理模块是通过AOP功能来实现声明式事务处理的。 Spring事务传播行为类型 PROPAGATION_REQUIRED：如果当前没有事务，就新建一个事务。如果已经存在一个事务中，加入到这个事务中。 PROPAGATION_REQUIRES_NEW：如果当前没有事务，就新建一个事务。如果当前存在事务，就把当前事务挂起，另建一个事务。 PROPAGATION_NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED 类似的操作。外套的事务异常可使内嵌事务回滚，反之不会。 PROPAGATION_SUPPORTS：支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_NOT_SUPPORTED：以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER：以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_MANDATORY：使用当前的事务，如果当前没有事务，就抛出异常。 Spring事务隔离级别 Read uncommitted：可能出现脏读(事务B读取了事务A尚未提交的数据) Read committed：避免了脏读，但是可能会造成不可重复读。（事务A事先读取了数据，事务B紧接了更新了数据，并提交了事务，而事务A再次读取该数据时，数据已经发生了改变。） Repeatable read：一旦事务开始别的事务就不能进行修改 Serializable：不仅可以避免脏读、不可重复读，还避免了幻像读。 Spring事务与数据库事务的关系？Spring事务实际上是使用了数据库事务。Spring在数据库之上又进一步进行了封装，可以在不同的项目、不同的操作中再次对事务的传播行为和隔离级别进行策略控制。 SpringMVC关键组件 核心控制器DispatcherServlet： 它负责处理HTTP请求, 加载配置文件, 初始化上下应用对象ApplicationContext（负责接收用户的请求并根据用户的请求返回相应的视图给用户。） handleMapping： 路径映射关系，根据URL匹配handler ViewResolver视图解析器：选择结果应该如何渲染 SpringMVC处理请求的流程 前端控制器DispatcherServlet获取用户发送的请求，DispatcherServlet查询handleMapping应将请求发给那个处理器， 处理器映射器查询后返回一个执行链(没有返回404) 然后DispatcherServlet将请求委托给对应的处理器适配器HandlerAdapter，适配器找到对应的页面控制器controller执行。 控制器controller从模型处调用业务对象，model返回模型数据，控制器返回ModelAndView 前端控制器通过匹配视图解析器查询正确的视图，请求view渲染视图并产生响应返回给用户 SpringMVC与Structs对比 Struts2是类级别的拦截，SpringMVC是方法级别的拦截 SpringMVC的方法之间基本上独立的，独享request response数据，方法之间不共享变量。而Struts2所有Action变量是共享的 拦截器实现机制上，Struts2有以自己的interceptor机制，SpringMVC用的是独立的AOP方式 SpringMVC的入口是servlet，而Struts2是filter HibernateHibernate的优缺点优点 封装了JDBC,简化了很多重复性代码 简化了DAO层编码工作 移植性好,支持各种数据库 没有实现任何接口,没有侵入性。所以说它是一个轻量级框架。缺点 由于对持久层封装过于完整，导致无法对SQL进行优化，无法灵活使用JDBC的原生SQL。Hibernate封装了JDBC，所以没有JDBC直接访问数据库效率高。（个人感觉原因在于Hibernate是对对象进行操作，然后利用反射原理将实体类中的字段按照annotation解析成一条或者多条sql语句，然后放入数据库执行。而JDBC是直接操作数据库） 使用ORM原则，导致配置过于复杂。表多的时候配置文件与内容很庞大。 如果项目中各个表中关系复杂，表之间的关系很多，在很多地方把lazy都设置false，会导致数据查询和加载很慢，尤其是级联查询的时候。 Hibernate在批量数据处理时有弱势，对于批量的修改，删除，不适合用Hibernate,这也是ORM框架的弱点 Hibernate API Configuration: 配置hibernate，启动hibernate,最后创建SessionFactory实例对象 SessionFactory: 初始化hibernate，创建session接口对象。线程安全线程共享 Session: 持久化管理器，负责数据的保存，更新，删除，加载和查询对象。表示应用程序与持久储存层之间交互操作的一个单线程对象。线程不安全[ThreadLocal] Transaction: 负责hibernate事务的管理 Query, Criteria: 负责数据的查询 Hibernate工作原理 读取并解析配置文件 读取并解析映射信息，创建SessionFactory 使用SessionFactory的openSession()获得一个Sesssion对象 创建事务Transation 持久化操作（反射机制获得持久化对象的各个属性） 成功了提交事务，否则rollback回滚事务 关闭Session 关闭SesstionFactory Hibernate Entity对象状态及其转换 临时态(Transient): 在数据库中不存在一条与它对应的记录[new(), delete()] 持久状态 (Persistent): save(), get(), load()等 游离态 (Detached): 游离对象在数据库中可能还存在一条与它对应的记录，只是现在这个游离对象脱离了Hibernate的缓存管理[close(), clean()] Hibernate缓存 Session缓存：事务缓存，一级缓存。减少数据库访问频率提高访问性能，保证缓存中的对象与数据库同步，位于缓存中的对象称为持久化对象 SessionFactory缓存：应用缓存，二级缓存。存放元数据和预定义SQL，被session共享 session().get()与session().load() session().get()：先在一级缓存中按实体类型与id查找，找到返回否则查询二级缓存。还是没找到查数据库，没有找到返回null session().load()：延迟加载，先查一级缓存，没有这个对象则创建代理。当使用这个对象时，如user.getName()或get(),才会触发sql语句去二级缓存和数据库查找。数据库没有抛出异常ObjectNotFoundException","categories":[{"name":"Java","slug":"Java","permalink":"http://oppalu.github.io/categories/Java/"}],"tags":[{"name":"Spring Hibernate Servlet J2EE","slug":"Spring-Hibernate-Servlet-J2EE","permalink":"http://oppalu.github.io/tags/Spring-Hibernate-Servlet-J2EE/"}]},{"title":"机器学习related(3) ———— 神经网络","slug":"机器学习related(3) ———— 神经网络","date":"2017-10-15T15:46:26.000Z","updated":"2017-10-16T02:21:12.000Z","comments":true,"path":"2017/10/15/机器学习related(3) ———— 神经网络/","link":"","permalink":"http://oppalu.github.io/2017/10/15/机器学习related(3) ———— 神经网络/","excerpt":"","text":"Model Representation神经网络模型是许多逻辑单元(Logistics Unit)按照不同的层级组织起来的网络，每一层的输出变量作为下一层的输入变量。如下图，是一个三层的神经网络，第一层为输入层(Input Layer)，最后一层为输出层(Output Layer)，中间的一层为隐藏层(Hidden Layer)。我们为每一层都增加一个偏倚单位(Bias Unit【值永远为1】)*注：①上述权重矩阵的大小为行是j+1层的激活单元数，列是j层的+1（有一个偏移单元）②h和g函数采用sigmoid函数，函数的形式见下 正向传播（Forward Propagation）对于上面的式子，重新改写一下第二层的计算：所以不难发现： NN LearningCost Function*注：这里的K是结果分类类别的数量 反向传播————最小化代价函数1）主要思想是先计算最后一层的误差，然后一层层的反向求出各层的误差（至倒数第二层）2）式子最后利用这些计算出来的偏导数就可以按以前的梯度下降法或别的方法来进行计算了 Unrolling Parameters把矩阵换为向量传递例子： Training的步骤注：①初始权重一般设成接近0的很小值","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"},{"name":"神经网络","slug":"神经网络","permalink":"http://oppalu.github.io/tags/神经网络/"}]},{"title":"机器学习related(2) ———— LDA","slug":"机器学习related(2) ———— LDA","date":"2017-10-11T12:39:40.000Z","updated":"2017-10-11T12:41:03.000Z","comments":true,"path":"2017/10/11/机器学习related(2) ———— LDA/","link":"","permalink":"http://oppalu.github.io/2017/10/11/机器学习related(2) ———— LDA/","excerpt":"","text":"基本思想输入分词后的文章集（一篇文章一行，是一个词袋）和主题数K，输出每篇文章的每个词的主题编号、每篇文章的主题概率分布、每个主题下词的概率分布等 LDA相关的前置知识二项分布C(n,k)p^k(1-p)^(n-k) 多项分布 Beta分布————二项分布的共轭先验分布期望是a/a+b dirichlet分布 gamma函数（阶乘在实数范围的扩展） 定义 性质 共轭先验分布先验概率，就是常识、经验所透露出的“因”的概率，后验概率就是在知道“果”之后，去推测“因”的概率。如果后验概率P(θ|x)和先验概率p(θ)满足同样的分布律，那么，先验分布和后验分布被叫做共轭分布，同时，先验分布叫做似然函数的共轭先验分布 LDA的生成过程1.对每一篇文档，从主题分布中抽取一个主题；2.从上述被抽到的主题所对应的单词分布中抽取一个单词；3.重复上述过程直至遍历文档中的每一个单词。 LDA整体流程文档集合D中每个文档d看作一个单词序列，wi表示第i个单词，设d有n个单词。D中涉及的所有不同单词组成一个大集合VOCABULARY（简称VOC），LDA以文档集合D作为输入，希望训练出的两个结果向量（设聚成k个topic，VOC中共包含m个词）：①对每个D中的文档d，对应到不同Topic的概率θd(pt1,…,ptk)，其中，pti表示d对应T中第i个topic的概率。pti=nti/n，其中nti表示d中对应第i个topic的词的数目，n是d中所有词的总数。②对每个T中的topic t，生成不同单词的概率φt(pw1,…,pwm)，其中，pwi表示t生成VOC中第i个单词的概率。pwi=Nwi/N，其中Nwi表示对应到topict的VOC中第i个单词的数目，N表示所有对应到topict的单词总数。LDA的核心公式如下：p(w|d)=p(w|t)p(t|d)直观的看这个公式，*就是可以通过当前的θd和φt给出了文档d中出现单词w的概率。其中p(t|d)利用θd计算得到，p(w|t)利用φt计算得到。 LDA的学习过程LDA算法开始时，先随机地给θd和φt赋值（对所有的d和t）。然后不断重复下面的迭代的学习过程： 针对一个特定的文档ds中的第i单词wi，如果令该单词对应的topic为tj，可以把上述公式改写为：pj(wi|ds)=p(wi|tj)*p(tj|ds) 枚举T中的topic，得到所有的pj(wi|ds)，其中j取值1~k。然后可以根据这些概率值结果为ds中的第i个单词wi选择一个topic。最简单的想法是取令pj(wi|ds)最大的tj 如果ds中的第i个单词wi在这里选择了一个与原先不同的topic，就会对θd和φt有影响了。它们的影响又会反过来影响对上面提到的p(w|d)的计算。对D中所有的d中的所有w进行一次p(w|d)的计算并重新选择topic看作一次迭代。这样进行n次循环迭代之后，就会收敛到LDA所需要的结果了。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"},{"name":"LDA","slug":"LDA","permalink":"http://oppalu.github.io/tags/LDA/"}]},{"title":"机器学习related(1)","slug":"机器学习related(1)","date":"2017-10-10T07:29:29.000Z","updated":"2017-10-10T07:30:18.000Z","comments":true,"path":"2017/10/10/机器学习related(1)/","link":"","permalink":"http://oppalu.github.io/2017/10/10/机器学习related(1)/","excerpt":"","text":"机器学习related(1) 监督学习：通过已有的训练样本（即已知数据以及其对应的输出）来训练，从而得到一个最优模型，再利用这个模型将所有新的数据样本映射为相应的输出结果非监督学习：事先没有任何训练数据样本，需要直接对数据进行建模。 一般m是样本数，n是特征值数，代价函数为J代价函数和梯度下降算法的代数描述 代价函数和梯度下降算法的矩阵算法 加快梯度下降的执行速度—-Feature Scaling思想：将各个feature的值标准化，使得取值范围大致都在-1&lt;=x&lt;=1之间 求最优解除了梯度下降外的方法【n&lt;10000时选择】—-Normal Equation（正规方程）","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"}]},{"title":"关于mac -bash- hexo- command not found的解决","slug":"关于mac -bash- hexo- command not found的解决","date":"2017-04-09T15:36:06.000Z","updated":"2019-02-01T14:56:05.649Z","comments":true,"path":"2017/04/09/关于mac -bash- hexo- command not found的解决/","link":"","permalink":"http://oppalu.github.io/2017/04/09/关于mac -bash- hexo- command not found的解决/","excerpt":"","text":"好久没写博客了，今天提交一下发现突然报了错：-bash: hexo: command not found。这时候就比较懵逼了，然后想了想会不会是环境变量没有配好的原因，结果去查了一下也没有找到网上说的路径下有hexo-cli文件夹，这时候就开始怀疑是不是自己以前安装的时候没有装成全局-g的。。。于是可以考虑重新装，使用npm install -g hexo-cli,这个时候你可能会遇到如下的报错信息：1234567891011121314151617181920212223242526272829npm ERR! tar.unpack untar error /Users/aprildove/.npm/hexo/3.2.2/package.tgznpm ERR! Darwin 15.3.0npm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;hexo&quot; &quot;-g&quot;npm ERR! node v4.4.5npm ERR! npm v2.15.5npm ERR! path /usr/local/lib/node_modules/hexonpm ERR! code EACCESnpm ERR! errno -13npm ERR! syscall mkdirnpm ERR! Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo&apos;npm ERR! at Error (native)npm ERR! &#123; [Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo&apos;]npm ERR! errno: -13,npm ERR! code: &apos;EACCES&apos;,npm ERR! syscall: &apos;mkdir&apos;,npm ERR! path: &apos;/usr/local/lib/node_modules/hexo&apos;,npm ERR! fstream_type: &apos;Directory&apos;,npm ERR! fstream_path: &apos;/usr/local/lib/node_modules/hexo&apos;,npm ERR! fstream_class: &apos;DirWriter&apos;,npm ERR! fstream_stack: npm ERR! [ &apos;/usr/local/lib/node_modules/npm/node_modules/fstream/lib/dir-writer.js:35:25&apos;,npm ERR! &apos;/usr/local/lib/node_modules/npm/node_modules/mkdirp/index.js:47:53&apos;,npm ERR! &apos;FSReqWrap.oncomplete (fs.js:82:15)&apos; ] &#125;npm ERR! npm ERR! Please try running this command again as root/Administrator.npm ERR! Please include the following file with any support request:npm ERR! /Users/aprildove/Workspace/github/npm-debug.log 这个是因为权限不够，加上sudo执行应该就没有问题了。。。然后安装成功后就可以愉快的hexo g和hexo d了为了防止之后可能还有问题可以在环境变量的配置文件中将hexo的环境变量路径加入:12//使用这句打开配置文件sudo vi ~/.bash_profile 在后面加入1/usr/local/lib/node_modules/hexo-cli/bin","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://oppalu.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://oppalu.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"http://oppalu.github.io/tags/github-pages/"}]},{"title":"react+material-ui的一些学习心得（二）","slug":"react+material-ui的一些学习心得（二）","date":"2016-12-29T07:45:16.000Z","updated":"2016-12-29T08:13:28.000Z","comments":true,"path":"2016/12/29/react+material-ui的一些学习心得（二）/","link":"","permalink":"http://oppalu.github.io/2016/12/29/react+material-ui的一些学习心得（二）/","excerpt":"上一篇介绍了一下使用react时的一些工具，这一篇就写写React和material-ui的一些学习笔记吧。同样比较粗糙简略","text":"上一篇介绍了一下使用react时的一些工具，这一篇就写写React和material-ui的一些学习笔记吧。同样比较粗糙简略 React什么是ReactReact 是一个用于构建用户界面的 JavaScript 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 使用npm安装React如果你的系统还不支持 Node.js 及 NPM 可以参考之前的几篇博文然后使用npm安装React的相关包12npm install react --savenpm install react-dom --save 小例子下面用一个简单的小例子来简单的介绍一下jsx，下文会做详细解释App.jsx12345678910111213import React from &apos;react&apos;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello World!!!&lt;br /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 然后引入组件并将其渲染到根元素 App 上123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./App.jsx&apos;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;)) 总的来看，React可自定义组件，如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import 将其导入即可使用。 React JSX使用可以将React JSX 代码可以放在一个独立文件上（js），然后通过下方代码使用1&lt;script type=&quot;text/babel&quot; src=&quot;...&quot;&gt;&lt;/script&gt; React组件要渲染 React 组件，只需创建一个大写字母开头的本地变量。例如12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello World！&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage /&gt;, document.getElementById(&apos;example&apos;)); 其中React.createClass 方法用于生成一个组件类 HelloMessage。React.render()第一个参数为实例化的组件对象，第二个是要放的地方。注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 传递参数如果我们需要向组件传递参数，可以使用 this.props 对象。注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name=&quot;Runoob&quot; /&gt;, document.getElementById(&apos;example&apos;)); 可以通过 getDefaultProps() 方法为 props 设置默认值 Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI 再次强调本文比较简略，具体内容可参见React官方文档 Material-ui这部分参见官方使用文档 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://www.ruanyifeng.com/blog/2015/03/react.htmlhttp://www.runoob.com/react/react-tutorial.htmlhttps://facebook.github.io/react/docs/hello-world.html","categories":[{"name":"React","slug":"React","permalink":"http://oppalu.github.io/categories/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://oppalu.github.io/tags/react/"}]},{"title":"react+material-ui的一些学习心得（一）","slug":"react+material-ui的一些学习心得（一）","date":"2016-12-29T03:28:28.000Z","updated":"2017-05-23T16:27:30.000Z","comments":true,"path":"2016/12/29/react+material-ui的一些学习心得（一）/","link":"","permalink":"http://oppalu.github.io/2016/12/29/react+material-ui的一些学习心得（一）/","excerpt":"因为人机交互课程要对之前的项目进行修改，用了别人的项目使用的是react+material-ui，所以对他们进行了一些简单的学习。这篇博文主要介绍了一下使用react时的一些工具，写的比较简单基本只有一些要点的记录，因为最开始是写给自己看的就比较简略。详细的学习可参见提供的博文地址 npm什么是npmnpm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。","text":"因为人机交互课程要对之前的项目进行修改，用了别人的项目使用的是react+material-ui，所以对他们进行了一些简单的学习。这篇博文主要介绍了一下使用react时的一些工具，写的比较简单基本只有一些要点的记录，因为最开始是写给自己看的就比较简略。详细的学习可参见提供的博文地址 npm什么是npmnpm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 安装npm安装可参见前一篇讲解hexo搭建时的下载方式 使用npm安装模块1npm install xxx -g 注：-g为可选参数，加上表示全局安装 本地安装放在./node_modules中，通过require()引入全局安装放在/usr/local或node的安装目录，直接在命令行使用 关于package.jsonpackage.json文件用来定义包的属性其中dependencies为依赖包列表，如果依赖包没有安装npm会自动安装到node_modules中 webpack什么是webpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 关于webpack的部分建议大家参考这篇博文，属于入门精品 工作方式给定主文件，从它开始找项目的所有依赖文件用loaders处理他们 webpack.config.js是webpack的配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 使用npm执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，直接使用npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, 使用webpack构建本地服务器使用本地服务器可以使得浏览器监测到代码修改并自动刷新修改后的结果，在webpack中进行配置之前需要单独安装它作为项目依赖1npm install --save-dev webpack-dev-server 在devserver的配置选项中inline设为true时源文件改变时会自动刷新页面 loader通过不同的loader，webpack通过调用外部的工具对不同格式的文件进行处理 配置可以使用配置文件中的module，其中： test：一个匹配loaders要处理的文件的拓展名的正则表达式 loader：loader include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹） query：为loaders提供额外的设置选项 例如在我们的项目中就使用babel来处理jsx文件，关于babel介绍参见下文123456789loaders: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: &apos;babel&apos;, query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125;] Babel什么是BabelBabel是一个编译JavaScript的平台，可以编译下一代的JavaScript标准（ES6，ES7）以及基于JavaScript进行了拓展的语言 Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包），使用npm对这些包进行安装 配置则在webpack配置文件的module中（见上文） PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://blog.csdn.net/kun5706947/article/details/52596766http://blog.csdn.net/zccz14/article/details/51421324http://www.runoob.com/nodejs/nodejs-npm.html","categories":[{"name":"React","slug":"React","permalink":"http://oppalu.github.io/categories/React/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://oppalu.github.io/tags/npm/"},{"name":"webpack","slug":"webpack","permalink":"http://oppalu.github.io/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"http://oppalu.github.io/tags/babel/"}]},{"title":"mac下利用hexo+github pages建立个人博客","slug":"mac下利用hexo-github-pages建立个人博客","date":"2016-12-15T11:22:16.000Z","updated":"2019-02-01T14:32:30.501Z","comments":true,"path":"2016/12/15/mac下利用hexo-github-pages建立个人博客/","link":"","permalink":"http://oppalu.github.io/2016/12/15/mac下利用hexo-github-pages建立个人博客/","excerpt":"折腾了一晚上终于搞定了自己的博客，觉得还是要写下来万一之后要重新弄然而zz了都不记得了，也给别的小伙伴做个参考吧~参考了很多博客，在后文会表示感谢的！用到的是hexo和github pages，当然也可以使用Jekyll（而且这个貌似是github官方比较推荐的，但是个人感觉hexo的theme更好看一点2333）废话不说了开始正题","text":"折腾了一晚上终于搞定了自己的博客，觉得还是要写下来万一之后要重新弄然而zz了都不记得了，也给别的小伙伴做个参考吧~参考了很多博客，在后文会表示感谢的！用到的是hexo和github pages，当然也可以使用Jekyll（而且这个貌似是github官方比较推荐的，但是个人感觉hexo的theme更好看一点2333）废话不说了开始正题 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。这里可以参考Hexo的中文官方文档 安装Hexo安装按照文档所给的步骤进行即可，在此列出一些较关键的步骤 安装前提首先确保电脑中已安装了下列应用程序：Node.jsGit 如果没有请根据以下安装指示完成安装： Git使用 Homebrew, 或下载安装程序安装。 Node.js（这里使用nvm来进行安装）首先安装nvm（cURL）:1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js1$ nvm install stable 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 建站安装 Hexo 完成后，在本地新建一个文件夹，并进入到文件夹目录下，执行12hexo init$ npm install 新建完成后，指定文件夹的目录如下：123456├── _config.yml├── package.json├── scaffolds├── source| ├── _posts└── themes 这里主要强调_config.yml，这是你的配置文件，themes文件夹中存放你的主题，source/_posts中存放的是你的博文，可使用markdown等格式 对于theme的使用，Hexo提供了众多模板,使用时将其下载解压至theme文件夹中，然后将_config.yml最后的theme后改成你想要使用的theme名 Github pagesGithub page可以方便的为项目建立介绍站点，也可以用来建立个人博客。 创建代码仓库首先你需要有一个Github账号，这里就不细说了，网上可以找到大量的教程。之后利用Github新建一个项目命名要按照username.github.io的格式，其中username是你的Github账号名 将Hexo部署到Gihub Page将_config.yml最后的deploy部分改成下面的1234deploy:type: gitrepo: https://github.com/username/username.github.io.gitbranch: master 将其中的username改为你自己的Github账号名，这样就部署好了~ Markdown我的博客使用的都是Markdown，Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。 Markdown具有很多优点：写作中添加简单符号即完成排版，所见即所得。让你专注于文字而不是排版。格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf等。Cmd Markdown 的主界面通常一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果 在线编辑工具在这里推荐一个在线Markdown编辑工具作业部落，而这个上传本地图片是要收费的，所以提供一个图床网站，上传本地图片到这里然后使用生成的URL即可[2018update, 图床似乎停止维护了，建议参考教程使用github作图床] 发布新博客利用hexo发布新博客时，使用下面的命令1$ hexo n &quot;new post&quot; 其中new post为文章标题，执行命令后，会在项目\\source_posts中生成new post.md文件，打开编写即可。也可以直接在\\source_posts中新建一个md文件。文件开头可使用下列部分12345title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: example #分类tags: [tag1,tag2,tag3] #文章标签，可空description: 附加一段文章摘要，字数最好在140字以内。 编写完成后，推送到服务器上，执行12$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://www.jianshu.com/p/05289a4bc8b2http://cyzus.github.io/2015/06/21/github-build-blog/https://hexo.io/zh-cn/docs/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://oppalu.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://oppalu.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"http://oppalu.github.io/tags/github-pages/"}]}]}