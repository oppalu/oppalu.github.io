{"meta":{"title":"Phoebe's blog","subtitle":"分享一些学习上的心得经验","description":"高露在Github上的个人博客","author":"Phoebe Gao","url":"http://oppalu.github.io"},"pages":[{"title":"分类","date":"2016-12-15T12:28:06.000Z","updated":"2016-12-15T12:28:36.000Z","comments":true,"path":"categories/index.html","permalink":"http://oppalu.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2016-12-15T12:25:57.000Z","updated":"2016-12-15T12:29:33.000Z","comments":true,"path":"tags/index.html","permalink":"http://oppalu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JAVA集合相关整理","slug":"JAVA集合相关整理","date":"2019-02-03T15:34:07.000Z","updated":"2019-02-03T16:58:09.809Z","comments":true,"path":"2019/02/03/JAVA集合相关整理/","link":"","permalink":"http://oppalu.github.io/2019/02/03/JAVA集合相关整理/","excerpt":"","text":"概述下面两张图所示是JAVA的集合框架图，从整体上可以发现JAVA容器主要包括了Collection和Map两种。List， Queue和Set集合共同继承Collection这个父接口，Map集合是单独的一个接口。 Collection ListList的每一个位置按照索引位置摆放，像一个柜子一层一层的，可以有重复的元素(根据索引找元素) ArrayList：基于动态数组实现,支持随机访问。 Vector：和ArrayList类似，但它是线程安全的。(开销也比 ArrayList 要大，访问速度更慢，因此要避免使用) LinkedList：基于双向链表实现，只能顺序访问，但是可以快速地在链表任何位置插入和删除元素。此外，LinkedList 还可以用作栈、队列和双向队列。 SetSet的每个元素不按顺序进行排序，无序不重复 HashSet：基于哈希表实现，是无序的，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的 TreeSet：基于红黑树实现，是有序的，但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 LinkedHashSet：具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 Queue PriorityQueue：基于堆结构实现，可用它来实现优先队列。 MapMap中的每一个元素都是按照键值对的方式存储，一个键对应一个值，键不可以重复，值可以重复，我们可以根据键找到值，也是无序的集合。 HashMap基于哈希表实现，对键进行散列，较快 TreeMap基于红黑树实现，用键的整体顺序对元素进行排序，将其组织成搜索树 HashTable与HashMap类似，区别在于HashMap线程不安全，键最多一个为null值可以为多个null。而HashTable线程安全，键与值都不能为null。（它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全） LinkedHashMap：使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用（LRU）顺序。 源码简单分析ArrayList（基于数组实现） 默认大小为10，当容量不够需要扩容时为原来的1.5倍。扩容操作需要调用 Arrays.copyOf()把原数组整个复制到新数组中，这个操作代价很高，因此最好在创建 ArrayList 对象时就指定大概的容量大小，减少扩容操作的次数。 由于基于数组实现，删除元素时复杂度为O(N) Fail-fast：当多个线程对同一个集合的内容进行操作时，就可能会产生fail-fast事件。ArrayList使用一个变量modCount来记录结构发生变化的次数(即添加/删除元素时)，在进行序列化或者迭代等操作时，需要比较操作前后modCount是否改变，如果改变了需要抛出ConcurrentModificationException异常。 Vector 实现与ArrayList类似，但是使用了synchronized进行同步。 每次扩容请求其大小的 2 倍空间 由于效率较低，如果需要同步可以使用Collections.synchronizedList()得到一个线程安全的 ArrayList。12List&lt;String&gt; list = new ArrayList&lt;&gt;();List&lt;String&gt; synList = Collections.synchronizedList(list); LinkedList(基于双向链表实现) 内部节点Node定义了前指针prev和后指针next12345private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev;&#125; HashMap Java定义了一个叫Entry的结构用来存储键值对。它是一个链表，包含了key, value, hashCode, next指针四个字段 Java定义了一个Entry类型的数组table。他的每个位置是一个桶，一个桶存放了一个Entry链表，同一个链表中存放哈希值相同的 Entry。 当插入一个键值对时，先计算K的hashcode，使用除留余数法得到所在的桶下标(如hashCode为115，HashMap大小为16，则得到桶的下标为115%16=3)。 当查找时，先根据hashCode计算键值对所在的桶，然后在对应的链表上顺序查找，时间复杂度和链表的长度成正比。 HashMap 允许插入键为 null 的键值对。但是因为无法调用 null 的 hashCode() 方法，也就无法确定该键值对的桶下标，因此使用第 0 个桶存放键为 null 的键值对。 HashTable与HashMap类似，使用 synchronized 来进行同步,可以插入键为 null 的 Entry。 ConcurrentHashMap 和 HashMap 实现上类似，差别在于 ConcurrentHashMap 采用了分段锁（Segment），每个分段锁维护着几个桶（HashEntry），多个线程可以同时访问不同分段锁上的桶，从而使其并发度更高。 其他HashSet是通过HashMap来实现的而TreeSet是通过TreeMap来实现的，因此这里不过多介绍 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！https://github.com/CyC2018/CS-Notes/blob/master/docs/notes/Java%20%E5%AE%B9%E5%99%A8.md","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://oppalu.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA集合","slug":"JAVA集合","permalink":"http://oppalu.github.io/tags/JAVA集合/"}]},{"title":"动态规划学习笔记（一）","slug":"动态规划学习笔记（一）","date":"2019-02-01T14:56:43.000Z","updated":"2019-02-01T14:57:39.776Z","comments":true,"path":"2019/02/01/动态规划学习笔记（一）/","link":"","permalink":"http://oppalu.github.io/2019/02/01/动态规划学习笔记（一）/","excerpt":"","text":"","categories":[{"name":"算法","slug":"算法","permalink":"http://oppalu.github.io/categories/算法/"}],"tags":[{"name":"动态规划","slug":"动态规划","permalink":"http://oppalu.github.io/tags/动态规划/"}]},{"title":"机器学习related(3) ———— 神经网络","slug":"机器学习related(3) ———— 神经网络","date":"2017-10-15T15:46:26.000Z","updated":"2017-10-16T02:21:12.000Z","comments":true,"path":"2017/10/15/机器学习related(3) ———— 神经网络/","link":"","permalink":"http://oppalu.github.io/2017/10/15/机器学习related(3) ———— 神经网络/","excerpt":"","text":"Model Representation神经网络模型是许多逻辑单元(Logistics Unit)按照不同的层级组织起来的网络，每一层的输出变量作为下一层的输入变量。如下图，是一个三层的神经网络，第一层为输入层(Input Layer)，最后一层为输出层(Output Layer)，中间的一层为隐藏层(Hidden Layer)。我们为每一层都增加一个偏倚单位(Bias Unit【值永远为1】)*注：①上述权重矩阵的大小为行是j+1层的激活单元数，列是j层的+1（有一个偏移单元）②h和g函数采用sigmoid函数，函数的形式见下 正向传播（Forward Propagation）对于上面的式子，重新改写一下第二层的计算：所以不难发现： NN LearningCost Function*注：这里的K是结果分类类别的数量 反向传播————最小化代价函数1）主要思想是先计算最后一层的误差，然后一层层的反向求出各层的误差（至倒数第二层）2）式子最后利用这些计算出来的偏导数就可以按以前的梯度下降法或别的方法来进行计算了 Unrolling Parameters把矩阵换为向量传递例子： Training的步骤注：①初始权重一般设成接近0的很小值","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"},{"name":"神经网络","slug":"神经网络","permalink":"http://oppalu.github.io/tags/神经网络/"}]},{"title":"机器学习related(2) ———— LDA","slug":"机器学习related(2) ———— LDA","date":"2017-10-11T12:39:40.000Z","updated":"2017-10-11T12:41:03.000Z","comments":true,"path":"2017/10/11/机器学习related(2) ———— LDA/","link":"","permalink":"http://oppalu.github.io/2017/10/11/机器学习related(2) ———— LDA/","excerpt":"","text":"基本思想输入分词后的文章集（一篇文章一行，是一个词袋）和主题数K，输出每篇文章的每个词的主题编号、每篇文章的主题概率分布、每个主题下词的概率分布等 LDA相关的前置知识二项分布C(n,k)p^k(1-p)^(n-k) 多项分布 Beta分布————二项分布的共轭先验分布期望是a/a+b dirichlet分布 gamma函数（阶乘在实数范围的扩展） 定义 性质 共轭先验分布先验概率，就是常识、经验所透露出的“因”的概率，后验概率就是在知道“果”之后，去推测“因”的概率。如果后验概率P(θ|x)和先验概率p(θ)满足同样的分布律，那么，先验分布和后验分布被叫做共轭分布，同时，先验分布叫做似然函数的共轭先验分布 LDA的生成过程1.对每一篇文档，从主题分布中抽取一个主题；2.从上述被抽到的主题所对应的单词分布中抽取一个单词；3.重复上述过程直至遍历文档中的每一个单词。 LDA整体流程文档集合D中每个文档d看作一个单词序列，wi表示第i个单词，设d有n个单词。D中涉及的所有不同单词组成一个大集合VOCABULARY（简称VOC），LDA以文档集合D作为输入，希望训练出的两个结果向量（设聚成k个topic，VOC中共包含m个词）：①对每个D中的文档d，对应到不同Topic的概率θd(pt1,…,ptk)，其中，pti表示d对应T中第i个topic的概率。pti=nti/n，其中nti表示d中对应第i个topic的词的数目，n是d中所有词的总数。②对每个T中的topic t，生成不同单词的概率φt(pw1,…,pwm)，其中，pwi表示t生成VOC中第i个单词的概率。pwi=Nwi/N，其中Nwi表示对应到topict的VOC中第i个单词的数目，N表示所有对应到topict的单词总数。LDA的核心公式如下：p(w|d)=p(w|t)p(t|d)直观的看这个公式，*就是可以通过当前的θd和φt给出了文档d中出现单词w的概率。其中p(t|d)利用θd计算得到，p(w|t)利用φt计算得到。 LDA的学习过程LDA算法开始时，先随机地给θd和φt赋值（对所有的d和t）。然后不断重复下面的迭代的学习过程： 针对一个特定的文档ds中的第i单词wi，如果令该单词对应的topic为tj，可以把上述公式改写为：pj(wi|ds)=p(wi|tj)*p(tj|ds) 枚举T中的topic，得到所有的pj(wi|ds)，其中j取值1~k。然后可以根据这些概率值结果为ds中的第i个单词wi选择一个topic。最简单的想法是取令pj(wi|ds)最大的tj 如果ds中的第i个单词wi在这里选择了一个与原先不同的topic，就会对θd和φt有影响了。它们的影响又会反过来影响对上面提到的p(w|d)的计算。对D中所有的d中的所有w进行一次p(w|d)的计算并重新选择topic看作一次迭代。这样进行n次循环迭代之后，就会收敛到LDA所需要的结果了。","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"},{"name":"LDA","slug":"LDA","permalink":"http://oppalu.github.io/tags/LDA/"}]},{"title":"机器学习related(1)","slug":"机器学习related(1)","date":"2017-10-10T07:29:29.000Z","updated":"2017-10-10T07:30:18.000Z","comments":true,"path":"2017/10/10/机器学习related(1)/","link":"","permalink":"http://oppalu.github.io/2017/10/10/机器学习related(1)/","excerpt":"","text":"机器学习related(1) 监督学习：通过已有的训练样本（即已知数据以及其对应的输出）来训练，从而得到一个最优模型，再利用这个模型将所有新的数据样本映射为相应的输出结果非监督学习：事先没有任何训练数据样本，需要直接对数据进行建模。 一般m是样本数，n是特征值数，代价函数为J代价函数和梯度下降算法的代数描述 代价函数和梯度下降算法的矩阵算法 加快梯度下降的执行速度—-Feature Scaling思想：将各个feature的值标准化，使得取值范围大致都在-1&lt;=x&lt;=1之间 求最优解除了梯度下降外的方法【n&lt;10000时选择】—-Normal Equation（正规方程）","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/categories/机器学习/"}],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://oppalu.github.io/tags/机器学习/"}]},{"title":"关于mac -bash- hexo- command not found的解决","slug":"关于mac -bash- hexo- command not found的解决","date":"2017-04-09T15:36:06.000Z","updated":"2019-02-01T14:56:05.649Z","comments":true,"path":"2017/04/09/关于mac -bash- hexo- command not found的解决/","link":"","permalink":"http://oppalu.github.io/2017/04/09/关于mac -bash- hexo- command not found的解决/","excerpt":"","text":"好久没写博客了，今天提交一下发现突然报了错：-bash: hexo: command not found。这时候就比较懵逼了，然后想了想会不会是环境变量没有配好的原因，结果去查了一下也没有找到网上说的路径下有hexo-cli文件夹，这时候就开始怀疑是不是自己以前安装的时候没有装成全局-g的。。。于是可以考虑重新装，使用npm install -g hexo-cli,这个时候你可能会遇到如下的报错信息：1234567891011121314151617181920212223242526272829npm ERR! tar.unpack untar error /Users/aprildove/.npm/hexo/3.2.2/package.tgznpm ERR! Darwin 15.3.0npm ERR! argv &quot;/usr/local/bin/node&quot; &quot;/usr/local/bin/npm&quot; &quot;install&quot; &quot;hexo&quot; &quot;-g&quot;npm ERR! node v4.4.5npm ERR! npm v2.15.5npm ERR! path /usr/local/lib/node_modules/hexonpm ERR! code EACCESnpm ERR! errno -13npm ERR! syscall mkdirnpm ERR! Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo&apos;npm ERR! at Error (native)npm ERR! &#123; [Error: EACCES: permission denied, mkdir &apos;/usr/local/lib/node_modules/hexo&apos;]npm ERR! errno: -13,npm ERR! code: &apos;EACCES&apos;,npm ERR! syscall: &apos;mkdir&apos;,npm ERR! path: &apos;/usr/local/lib/node_modules/hexo&apos;,npm ERR! fstream_type: &apos;Directory&apos;,npm ERR! fstream_path: &apos;/usr/local/lib/node_modules/hexo&apos;,npm ERR! fstream_class: &apos;DirWriter&apos;,npm ERR! fstream_stack: npm ERR! [ &apos;/usr/local/lib/node_modules/npm/node_modules/fstream/lib/dir-writer.js:35:25&apos;,npm ERR! &apos;/usr/local/lib/node_modules/npm/node_modules/mkdirp/index.js:47:53&apos;,npm ERR! &apos;FSReqWrap.oncomplete (fs.js:82:15)&apos; ] &#125;npm ERR! npm ERR! Please try running this command again as root/Administrator.npm ERR! Please include the following file with any support request:npm ERR! /Users/aprildove/Workspace/github/npm-debug.log 这个是因为权限不够，加上sudo执行应该就没有问题了。。。然后安装成功后就可以愉快的hexo g和hexo d了为了防止之后可能还有问题可以在环境变量的配置文件中将hexo的环境变量路径加入:12//使用这句打开配置文件sudo vi ~/.bash_profile 在后面加入1/usr/local/lib/node_modules/hexo-cli/bin","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://oppalu.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://oppalu.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"http://oppalu.github.io/tags/github-pages/"}]},{"title":"react+material-ui的一些学习心得（二）","slug":"react+material-ui的一些学习心得（二）","date":"2016-12-29T07:45:16.000Z","updated":"2016-12-29T08:13:28.000Z","comments":true,"path":"2016/12/29/react+material-ui的一些学习心得（二）/","link":"","permalink":"http://oppalu.github.io/2016/12/29/react+material-ui的一些学习心得（二）/","excerpt":"上一篇介绍了一下使用react时的一些工具，这一篇就写写React和material-ui的一些学习笔记吧。同样比较粗糙简略","text":"上一篇介绍了一下使用react时的一些工具，这一篇就写写React和material-ui的一些学习笔记吧。同样比较粗糙简略 React什么是ReactReact 是一个用于构建用户界面的 JavaScript 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。 使用npm安装React如果你的系统还不支持 Node.js 及 NPM 可以参考之前的几篇博文然后使用npm安装React的相关包12npm install react --savenpm install react-dom --save 小例子下面用一个简单的小例子来简单的介绍一下jsx，下文会做详细解释App.jsx12345678910111213import React from &apos;react&apos;;class App extends React.Component &#123; render() &#123; return ( &lt;div&gt; Hello World!!!&lt;br /&gt; &lt;/div&gt; ); &#125;&#125;export default App; 然后引入组件并将其渲染到根元素 App 上123456import React from &apos;react&apos;;import ReactDOM from &apos;react-dom&apos;;import App from &apos;./App.jsx&apos;;ReactDOM.render(&lt;App /&gt;, document.getElementById(&apos;app&apos;)) 总的来看，React可自定义组件，如果想要组件可以在任何的应用中使用，需要在创建后使用 export 将其导出，在使用组件的文件使用 import 将其导入即可使用。 React JSX使用可以将React JSX 代码可以放在一个独立文件上（js），然后通过下方代码使用1&lt;script type=&quot;text/babel&quot; src=&quot;...&quot;&gt;&lt;/script&gt; React组件要渲染 React 组件，只需创建一个大写字母开头的本地变量。例如12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello World！&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage /&gt;, document.getElementById(&apos;example&apos;)); 其中React.createClass 方法用于生成一个组件类 HelloMessage。React.render()第一个参数为实例化的组件对象，第二个是要放的地方。注意，原生 HTML 元素名以小写字母开头，而自定义的 React 类名以大写字母开头，比如 HelloMessage 不能写成 helloMessage。除此之外还需要注意组件类只能包含一个顶层标签，否则也会报错。 传递参数如果我们需要向组件传递参数，可以使用 this.props 对象。注意，在添加属性时， class 属性需要写成 className ，for 属性需要写成 htmlFor ，这是因为 class 和 for 是 JavaScript 的保留字。 12345678910var HelloMessage = React.createClass(&#123; render: function() &#123; return &lt;h1&gt;Hello &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125;);ReactDOM.render( &lt;HelloMessage name=&quot;Runoob&quot; /&gt;, document.getElementById(&apos;example&apos;)); 可以通过 getDefaultProps() 方法为 props 设置默认值 Ajax组件的数据来源，通常是通过 Ajax 请求从服务器获取，可以使用 componentDidMount 方法设置 Ajax 请求，等到请求成功，再用 this.setState 方法重新渲染 UI 再次强调本文比较简略，具体内容可参见React官方文档 Material-ui这部分参见官方使用文档 PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://www.ruanyifeng.com/blog/2015/03/react.htmlhttp://www.runoob.com/react/react-tutorial.htmlhttps://facebook.github.io/react/docs/hello-world.html","categories":[{"name":"React","slug":"React","permalink":"http://oppalu.github.io/categories/React/"}],"tags":[{"name":"react","slug":"react","permalink":"http://oppalu.github.io/tags/react/"}]},{"title":"react+material-ui的一些学习心得（一）","slug":"react+material-ui的一些学习心得（一）","date":"2016-12-29T03:28:28.000Z","updated":"2017-05-23T16:27:30.000Z","comments":true,"path":"2016/12/29/react+material-ui的一些学习心得（一）/","link":"","permalink":"http://oppalu.github.io/2016/12/29/react+material-ui的一些学习心得（一）/","excerpt":"因为人机交互课程要对之前的项目进行修改，用了别人的项目使用的是react+material-ui，所以对他们进行了一些简单的学习。这篇博文主要介绍了一下使用react时的一些工具，写的比较简单基本只有一些要点的记录，因为最开始是写给自己看的就比较简略。详细的学习可参见提供的博文地址 npm什么是npmnpm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。","text":"因为人机交互课程要对之前的项目进行修改，用了别人的项目使用的是react+material-ui，所以对他们进行了一些简单的学习。这篇博文主要介绍了一下使用react时的一些工具，写的比较简单基本只有一些要点的记录，因为最开始是写给自己看的就比较简略。详细的学习可参见提供的博文地址 npm什么是npmnpm是随同NodeJS一起安装的包管理工具，能解决NodeJS代码部署上的很多问题，常见的使用场景有以下几种： 允许用户从NPM服务器下载别人编写的第三方包到本地使用。 允许用户从NPM服务器下载并安装别人编写的命令行程序到本地使用。 允许用户将自己编写的包或命令行程序上传到NPM服务器供别人使用。 安装npm安装可参见前一篇讲解hexo搭建时的下载方式 使用npm安装模块1npm install xxx -g 注：-g为可选参数，加上表示全局安装 本地安装放在./node_modules中，通过require()引入全局安装放在/usr/local或node的安装目录，直接在命令行使用 关于package.jsonpackage.json文件用来定义包的属性其中dependencies为依赖包列表，如果依赖包没有安装npm会自动安装到node_modules中 webpack什么是webpackWebPack可以看做是模块打包机：它做的事情是，分析你的项目结构，找到JavaScript模块以及其它的一些浏览器不能直接运行的拓展语言（Scss，TypeScript等），并将其打包为合适的格式以供浏览器使用。 关于webpack的部分建议大家参考这篇博文，属于入门精品 工作方式给定主文件，从它开始找项目的所有依赖文件用loaders处理他们 webpack.config.js是webpack的配置文件，这个配置文件其实也是一个简单的JavaScript模块，可以把所有的与构建相关的信息放在里面。1234567module.exports = &#123; entry: __dirname + &quot;/app/main.js&quot;,//唯一入口文件 output: &#123; path: __dirname + &quot;/public&quot;,//打包后的文件存放的地方 filename: &quot;bundle.js&quot;//打包后输出文件的文件名 &#125;&#125; 使用npm执行打包任务执行类似于node_modules/.bin/webpack这样的命令其实是比较烦人且容易出错的，直接使用npm可以引导任务执行，对其进行配置后可以使用简单的npm start命令来代替这些繁琐的命令。在package.json中对npm的脚本部分进行相关设置即可 123&quot;scripts&quot;: &#123; &quot;start&quot;: &quot;webpack&quot; //配置的地方就是这里啦，相当于把npm的start命令指向webpack命令 &#125;, 使用webpack构建本地服务器使用本地服务器可以使得浏览器监测到代码修改并自动刷新修改后的结果，在webpack中进行配置之前需要单独安装它作为项目依赖1npm install --save-dev webpack-dev-server 在devserver的配置选项中inline设为true时源文件改变时会自动刷新页面 loader通过不同的loader，webpack通过调用外部的工具对不同格式的文件进行处理 配置可以使用配置文件中的module，其中： test：一个匹配loaders要处理的文件的拓展名的正则表达式 loader：loader include/exclude：手动添加必须处理的文件（文件夹）或屏蔽不需要处理的文件（文件夹） query：为loaders提供额外的设置选项 例如在我们的项目中就使用babel来处理jsx文件，关于babel介绍参见下文123456789loaders: [ &#123; test: /\\.jsx?$/, exclude: /node_modules/, loader: &apos;babel&apos;, query: &#123; presets: [&apos;es2015&apos;, &apos;react&apos;] &#125; &#125;] Babel什么是BabelBabel是一个编译JavaScript的平台，可以编译下一代的JavaScript标准（ES6，ES7）以及基于JavaScript进行了拓展的语言 Babel的安装与配置Babel其实是几个模块化的包，其核心功能位于称为babel-core的npm包中，不过webpack把它们整合在一起使用，但是对于每一个你需要的功能或拓展，你都需要安装单独的包（用得最多的是解析Es6的babel-preset-es2015包和解析JSX的babel-preset-react包），使用npm对这些包进行安装 配置则在webpack配置文件的module中（见上文） PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://blog.csdn.net/kun5706947/article/details/52596766http://blog.csdn.net/zccz14/article/details/51421324http://www.runoob.com/nodejs/nodejs-npm.html","categories":[{"name":"React","slug":"React","permalink":"http://oppalu.github.io/categories/React/"}],"tags":[{"name":"npm","slug":"npm","permalink":"http://oppalu.github.io/tags/npm/"},{"name":"webpack","slug":"webpack","permalink":"http://oppalu.github.io/tags/webpack/"},{"name":"babel","slug":"babel","permalink":"http://oppalu.github.io/tags/babel/"}]},{"title":"mac下利用hexo+github pages建立个人博客","slug":"mac下利用hexo-github-pages建立个人博客","date":"2016-12-15T11:22:16.000Z","updated":"2019-02-01T14:32:30.501Z","comments":true,"path":"2016/12/15/mac下利用hexo-github-pages建立个人博客/","link":"","permalink":"http://oppalu.github.io/2016/12/15/mac下利用hexo-github-pages建立个人博客/","excerpt":"折腾了一晚上终于搞定了自己的博客，觉得还是要写下来万一之后要重新弄然而zz了都不记得了，也给别的小伙伴做个参考吧~参考了很多博客，在后文会表示感谢的！用到的是hexo和github pages，当然也可以使用Jekyll（而且这个貌似是github官方比较推荐的，但是个人感觉hexo的theme更好看一点2333）废话不说了开始正题","text":"折腾了一晚上终于搞定了自己的博客，觉得还是要写下来万一之后要重新弄然而zz了都不记得了，也给别的小伙伴做个参考吧~参考了很多博客，在后文会表示感谢的！用到的是hexo和github pages，当然也可以使用Jekyll（而且这个貌似是github官方比较推荐的，但是个人感觉hexo的theme更好看一点2333）废话不说了开始正题 什么是HexoHexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。这里可以参考Hexo的中文官方文档 安装Hexo安装按照文档所给的步骤进行即可，在此列出一些较关键的步骤 安装前提首先确保电脑中已安装了下列应用程序：Node.jsGit 如果没有请根据以下安装指示完成安装： Git使用 Homebrew, 或下载安装程序安装。 Node.js（这里使用nvm来进行安装）首先安装nvm（cURL）:1$ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js1$ nvm install stable 安装Hexo所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。1$ npm install -g hexo-cli 建站安装 Hexo 完成后，在本地新建一个文件夹，并进入到文件夹目录下，执行12hexo init$ npm install 新建完成后，指定文件夹的目录如下：123456├── _config.yml├── package.json├── scaffolds├── source| ├── _posts└── themes 这里主要强调_config.yml，这是你的配置文件，themes文件夹中存放你的主题，source/_posts中存放的是你的博文，可使用markdown等格式 对于theme的使用，Hexo提供了众多模板,使用时将其下载解压至theme文件夹中，然后将_config.yml最后的theme后改成你想要使用的theme名 Github pagesGithub page可以方便的为项目建立介绍站点，也可以用来建立个人博客。 创建代码仓库首先你需要有一个Github账号，这里就不细说了，网上可以找到大量的教程。之后利用Github新建一个项目命名要按照username.github.io的格式，其中username是你的Github账号名 将Hexo部署到Gihub Page将_config.yml最后的deploy部分改成下面的1234deploy:type: gitrepo: https://github.com/username/username.github.io.gitbranch: master 将其中的username改为你自己的Github账号名，这样就部署好了~ Markdown我的博客使用的都是Markdown，Markdown 是一种简单的、轻量级的标记语法。用户可以使用诸如 * # 等简单的标记符号以最小的输入代价生成极富表现力的文档。 Markdown具有很多优点：写作中添加简单符号即完成排版，所见即所得。让你专注于文字而不是排版。格式转换方便，Markdown 的文本你可以轻松转换为 html、pdf等。Cmd Markdown 的主界面通常一分为二，左边为编辑区，右边为预览区，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果 在线编辑工具在这里推荐一个在线Markdown编辑工具作业部落，而这个上传本地图片是要收费的，所以提供一个图床网站，上传本地图片到这里然后使用生成的URL即可[2018update, 图床似乎停止维护了，建议参考教程使用github作图床] 发布新博客利用hexo发布新博客时，使用下面的命令1$ hexo n &quot;new post&quot; 其中new post为文章标题，执行命令后，会在项目\\source_posts中生成new post.md文件，打开编写即可。也可以直接在\\source_posts中新建一个md文件。文件开头可使用下列部分12345title: postName #文章页面上的显示名称，可以任意修改，不会出现在URL中date: 2013-12-02 15:30:16 #文章生成时间，一般不改，当然也可以任意修改categories: example #分类tags: [tag1,tag2,tag3] #文章标签，可空description: 附加一段文章摘要，字数最好在140字以内。 编写完成后，推送到服务器上，执行12$ hexo g #生成$ hexo d #部署 # 可与hexo g合并为 hexo d -g PS：在学习的过程中，参考了许多博客，这里对他们表示感谢！http://www.jianshu.com/p/05289a4bc8b2http://cyzus.github.io/2015/06/21/github-build-blog/https://hexo.io/zh-cn/docs/","categories":[{"name":"Hexo","slug":"Hexo","permalink":"http://oppalu.github.io/categories/Hexo/"}],"tags":[{"name":"hexo","slug":"hexo","permalink":"http://oppalu.github.io/tags/hexo/"},{"name":"github pages","slug":"github-pages","permalink":"http://oppalu.github.io/tags/github-pages/"}]}]}